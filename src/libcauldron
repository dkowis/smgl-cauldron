#!/bin/bash
#---------------------------------------------------------------------
##
##=head1 SYNOPSIS
##
##  libcauldron is a set of functions used internally by the cauldron script
##
##=head1 COPYRIGHT
##
##  Copyright 2007 by the Cauldron Team
##
##=head1 FUNCTIONS
##
##=over 4
##
#---------------------------------------------------------------------

#---------------------------------------------------------------------
##
## @param Filename
##
## 
##
#---------------------------------------------------------------------
function cauldron_lock_start_transaction() {
}

#---------------------------------------------------------------------
##
## @param Filename
##
## 
##
#---------------------------------------------------------------------
function cauldron_lock_commit_transaction() {
}

#---------------------------------------------------------------------
##
## @param Filename
## @param Variable
## @param Value
##
## Modifies the values assigned to variables present in a config file.
## Filename is typically either cauldron/config or cauldron/local/config.
## Variable is the name of the variable to modify/update, and Value is the
## value to assign to it.
##
#---------------------------------------------------------------------
function cauldron_modify_config() {
  local FILE=$1
  local VAR=$2
  local VAL=$3
  local COL=$((20-${#1}))
  local tFILE=""
  local TEMP=""

  if [[ -f ${FILE} ]]
  then
    # Open tFILE for the transactions for FILE, to be committed back to
    # FILE later.
    tFILE=$(cauldron_lock_start_transaction ${FILE})

    # Copy everything _except_ the var we want to change to tFILE
    # This effectively deletes the previous reference to var (in tFILE)
    $(grep -v "^[[:blank:]]*${1}=" ${FILE} > ${tFILE})

    # Justify (center) the text in the file based on the length of the var
    [[ COL -lt 0 ]] && COL=0
    for (( ; COL>0 ; COL-- )) ;
    do
      TEMP="${TEMP} "
    done

    # Write out the new variable=value assignment, including justification
    # whitespace, to tFILE
    echo "${TEMP}${1}=\"${2}\"" >> ${tFILE}

    # Commit the changes back out to the original FILE
    cauldron_lock_commit_transaction ${FILE}
}

#---------------------------------------------------------------------
##
## Prepares a chroot environment
##
#---------------------------------------------------------------------
function cauldron_chroot_init() {
  mount --bind ${HOST}/dev ${CAULDRON_BUILD}/dev
  mount --bind ${HOST}/dev/pts ${CAULDRON_BUILD}/dev/pts
  mount --bind ${HOST}/proc ${CAULDRON_BUILD}/proc
}

#---------------------------------------------------------------------
##
## Cleans up the chroot environment after it is no longer needed
##
#---------------------------------------------------------------------
function cauldron_chroot_done() {
  umount ${CAULDRON_BUILD}/proc
  umount ${CAULDRON_BUILD}/dev/pts
  umount ${CAULDRON_BUILD}/dev
}

#---------------------------------------------------------------------
##
## Scans the sorcery archspec files to find the host triplet
## This will be used to set the value of HOST in /etc/cauldron/config
##
#---------------------------------------------------------------------
function cauldron_get_host_triple() {
  local HOST_ARCH
  local ARCH_SPEC
  local HOST_TRIPLE
  local SPEC_FILE

  # get the value for the HOST triplet from sorcery archspecs
  for spec in ${HOST_ARCH_PATH[@]}
  do
    if [[ $(find --version|grep -q 'version 4\.1\(\.\|$\)') == 1 ]]
    then
      ARCH_SPEC=$(find ${spec} -perm 400 -type f -name ${HOST_ARCH} \
        -print 2>/dev/null)
    else
      ARCH_SPEC=$(find -L ${spec} -perm 400 -type f -name ${HOST_ARCH} \
        -print 2>/dev/null)
    fi
    [[ ARCH_SPEC ]] && break
  done
  HOST_TRIPLE=$(grep "HOST=" ${ARCH_SPEC} | cut -d = -f 2)

  echo ${HOST_TRIPLE}
}

#---------------------------------------------------------------------
##
## Generates the base toolchain using the HOST information. This is
## done by unpacking the cache file for each spell required for the
## toolchain if it exists. If it does not exist, this may be because
## caching is disabled on the host machine, or perhaps the cache file
## was deleted by accident. Otherwise the spell must be cast within
## a chroot environment in the CAULDRON_BUILD directory.
##
#---------------------------------------------------------------------
function cauldron_create_base_toolchain() {
  local SPELL
  local VERSION
  local SPELL_CACHE
  local HOST_TRIPLE
  local CACHE_EXTENSION

  # set the value for HOST_TRIPLE
  HOST_TRIPLE=$(cauldron_get_host_triple)

  # grab the list of spells needed as the base tool-chain which will be
  # used to create the cross-compile tool-chain
  for SPELL in ${HOST_TOOLCHAIN}
  do
    # grab the version for the spell from sorcery's state info
    # on what's installed
    VERSION=$(grep "^${SPELL}" ${HOST_PACKAGES} | cut -d : -f 4)

    if [[ ${VERSION} ]]
    then
      # set SPELL_CACHE as shorthand for SPELL-VERSION-HOST_TRIPLE.tar.bz2
      SPELL_CACHE="${SPELL}-${VERSION}-${HOST_TRIPLE}.tar${CACHE_EXTENSION}"

      # check to see if there is already a cache file from sorcery
      # this check could be based on spell-{names,versions} reported by
      # gaze/sorcery/dispel. Mirroring code in dispel might be the best bet,
      # since that has to find the version currently installed anyway.
      if [[ -f ${HOST_SORCERY_SPOOL}/${SPELL_CACHE} ]]
      then
        # found a cache file, copy it to the BUILD dir
        cp ${HOST_SORCERY_SPOOL}/${SPELL_CACHE} ${CAULDRON_BUILD}
      else
        # couldn't find a cache file, so we'll need to build one
        cauldron_build_cache_file ${SPELL}
      fi
      # unpack the cache file, effectively installing
      # the spell into the BUILD dir
      # the unpacking is done against the BUILD dir as the root dir, so
      # this should not touch the HOST filesystem at all
      tar xjf ${CAULDRON_BUILD}/${SPELL_CACHE} -C ${CAULDRON_BUILD}/
    else
      # the spell is not present on the HOST system, so it must be cast
      # inside a chroot
      cauldron_chroot_init
      chroot ${CAULDRON_BUILD} ${CAULDRON_CAST} ${SPELL}
      cauldron_chroot_done
    fi
  done
}

#---------------------------------------------------------------------
## @param stage
##
## Configures the toolchain for building on the TARGET system. In other
## words, this sets the options/variables necessary to build a
## cross-compiler system to generate binaries for the target system. The
## parameter "stage" is an int and sets the variables for stage1 and stage2 of
## the cross-compile. Stage1 is the building of the initial tools. Stage2 is for
## the building of glibc, because it's a little bit special. Stage3 is
## the cross-compilation of the basesystem via sorcery rebuild using the
## cross-compiler.
##
#---------------------------------------------------------------------
function cauldron_configure_toolchain() {
  local STAGE=$1

  case ${STAGE} in
    1)
      cauldron_modify_config ${TARGET_LOCAL_CFG} CUSTOM_CFLAGS \ 
        "--host=${HOST} --target=${TARGET}"
    ;;
    2)
      cauldron_modify_config ${TARGET_LOCAL_CFG} CUSTOM_CFLAGS \
        "--build=${HOST} --host=${TARGET}"
    ;;
    3)
      cauldron_modify_config ${TARGET_LOCAL_CFG} CUSTOM_CFLAGS \
        "--build=${HOST} --host=${TARGET} --target=${TARGET}"
    ;;
  esac
}

#---------------------------------------------------------------------
## @param XXX
##
## This builds the cross-compiler to produce the TARGET binaries.
##
#---------------------------------------------------------------------
function cauldron_create_target_toolchain() {
  # build the stage 1 tools
  cauldron_configure_toolchain 1
  cauldron_chroot_init
  chroot ${CAULDRON_BUILD} ${CAULDRON_CAST} binutils
  chroot ${CAULDRON_BUILD} ${CAULDRON_CAST} gcc
  cauldron_chroot_done

  # build glibc (stage 2)
  cauldron_configure_toolchain 2
  cauldron_chroot_init
  chroot ${CAULDRON_BUILD} ${CAULDRON_CAST} glibc
  cauldron_chroot_done

  # rebuild gcc (still stage 1, but this time linked against the
  # cross-glibc
  cauldron_configure_toolchain 1
  cauldron_chroot_init
  chroot ${CAULDRON_BUILD} ${CAULDRON_CAST} gcc
  cauldron_chroot_done

  # do a sorcery rebuild inside the BUILD dir to
  # generate the cross-compile tool-chain (stage 3)
  cauldron_configure_toolchain 3
  cauldron_chroot_init
  chroot ${CAULDRON_BUILD} ${CAULDRON_REBUILD}
  cauldron_chroot_done
}

#---------------------------------------------------------------------
## @param XXX
##
## Generates the installation system that will be copied from the ISO to the
## target system as a tarball
##
#---------------------------------------------------------------------
function cauldron_build_iso_system() {
}

#---------------------------------------------------------------------
## @param XXX
##
## Handles setting up the init process on the ISO. The ISO init is
## responsible for detecting hardware, loading device drivers, setting
## console fonts, etc.
##
#---------------------------------------------------------------------
function cauldron_iso_init() {
}

#---------------------------------------------------------------------
## @param INSTALLER_MODULE - one of shell or menu (future: X?)
##
## Adds the given installer to the ISO system. The user can then choose this
## installer either at boot-time or run-time, depending on the installer
##
#---------------------------------------------------------------------
function cauldron_add_installer() {
  local MODULE=$1

  cp ${} ${CAULDRON_BUILD}/${CAULDRON_MODULEDIR}
  ln -sf ${CAULDRON_BUILD}/${CAULDRON_MODULEDIR} /sbin/
}

#---------------------------------------------------------------------
## @param CLEANFILE - a file that lists paths to remove (absolute paths,
## relative to a chroot of the iso), one file/path per line
##
## Cleans out unneeded files that were used to generate the ISO, but should
## not be present on the final ISO system
##
#---------------------------------------------------------------------
function cauldron_clean_iso_system() {
  local CLEANFILE=$1

  [[ -z "$CLEANFILE" ]] && return 1

  for i in $(sort -r $CLEANFILE)
  do
    if [[ -d $i ]]
    then
      echo "Attempting to remove directory $i..."
      rmdir $i
    else
      echo "Deleting $i"
      rm $i
    fi
  done
  return 0
}

#---------------------------------------------------------------------
## @param KEEP - whether or not to keep the original .iso file in addition to
## the compressed .iso.bz2
##
## Builds the ISO filesystem using the generated ISO data and the filename
## set in the cauldron config file.
##
#---------------------------------------------------------------------
function cauldron_mkisofs() {
  local KEEP=$1

  mkisofs -R -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot \
    -boot-load-size 4 -boot-info-table -o ${SMGL_ISO} ${CAULDRON_BUILD}

  if [[ KEEP == "1" ]] ;
  then
    bzip2 -k ${SMGL_ISO}
  else
    bzip2 ${SMGL_ISO}
  fi
}

#---------------------------------------------------------------------
##
## Wrapper function that calls all the functions necessary to generate the
## final ISO file in the correct order
##
#---------------------------------------------------------------------
function cauldron_build_iso() {
  # set up basic tool-chain in order to cross-compile for target later
  cauldron_create_toolchain
  
  # copy the host's resolv.conf in order to dl packages from net
  cp -L /etc/resolv.conf ${CAULDRON_BUILD}/etc/resolv.conf
  
  # set up chroot for building inside $CAULDRON_BUILD
  cauldron_chroot_init
  
  # build the cross-compile tool-chain targeted for the target sys
  ${CAULDRON_CHROOT} cauldron_create_target_toolchain
  
  # use the cross-compile tool-chain to cast all spells needed for
  # the iso system
  ${CAULDRON_CHROOT} cauldron_build_iso_system
  
  # configure the iso init system, initrd/initramfs, etc.
  ${CAULDRON_CHROOT} cauldron_iso_init
  
  # build/create/copy/whatever installer system/data into the iso
  ${CAULDRON_CHROOT} cauldron_add_installer
  
  # remove unnecessary files from iso and free up space
  # this needs to have error-checking added in later
  for cleaner in ${CAULDRON_BASE}/cleaners/* ;
  do
    cp ${CAULDRON_BASE}/cleaners/${cleaner} ${CAULDRON_BUILD}/
    ${CAULDRON_CHROOT} cauldron_clean_iso_system /${cleaner}
    ${CAULDORN_CHROOT} rm /${cleaner}
  done
  
  # finished with iso building, clean up from chroot setup
  cauldron_chroot_done
  
  # create the iso fs from the build dir
  cauldron_mkisofs $CAULDRON_KEEPISO
}

#---------------------------------------------------------------------
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#---------------------------------------------------------------------

# vim:ai:tw=80:tabstop=2:softtabstop=2:shiftwidth=2:expandtab
