#!/bin/bash

load_partitions() {
  #   Device Boot Start   End    MiB    #blocks   Id  System
  #/dev/sda1   *     0+  9538-  9539-   9767488+  83  Linux
  #/dev/sda2      9538+ 10236-   699-    714892+  82  Linux swap / Solaris

  PARTITIONS=()
  local i=0
  local PART SIZE TYPE
  while read PART _ _ SIZE _ _ TYPE ;do
    [[ "$TYPE" == "Empty" ]] && continue
    PARTITIONS[i++]=$PARTITION
    PARTITIONS[i++]="$SIZE MiB, $TYPE"
    # Poor man's pipe: doesn't spawn a subshell.
  done < <(sfdisk -l -uM | grep '^/' |
    sed 's/\*//;s/ \+/\t/g' | cut -d$'\t' -f1,5,7-)
}

mkfs_command() {
  case $1 in
        ext2)  echo  "mke2fs $2"      ;;
        ext3)  echo  "mke2fs -j $2"   ;;
    reiserfs)  echo  "mkreiserfs $2"  ;;
         xfs)  echo  "mkfs.xfs -f $2" ;; # ignore existing partition
         jfs)  echo  "mkfs.jfs $2"    ;;
        swap)  echo  "mkswap $2"      ;;
      custom)  echo  "... $2"         ;;
           *)  return 1               ;;
  esac
  return 0
}

function initial() {
  menu_intro "Intro: disk-format" \
"In this menu you will be formatting your disk.
blah blah blather, ignorum ipsorum latin pretend
more junk to get some test text creativity all
gone and this should do"
  STATE=get_part
  return 0
}

function get_part() {
  load_partitions
  RESULT=$(menu_central_menu "Partition selection menu" \
           "Select a partition to format or hit 'done'" \
           "${PARTITIONS[@]}" custom "Enter one manually")
  rc=$?
  if [[ $rc == 1 ]] ;then
    STATE=initial
    return 0
  elif [[ $rc == 3 ]] ;then
    STATE=finish
    return 0
  fi

  PARTITION=$RESULT
  if [[ $PARTITION == custom ]] ;then
    STATE=enter_part
  else
    STATE=get_fstype
  fi
}

function enter_part() {
  RESULT=$(menu_inputbox "Enter partition" \
           "Please enter a partition to be formatted (including /dev/)" \
           "/dev/") ||
  {
    STATE=get_part
    return 0
  }
  PARTITION=$RESULT
  STATE=get_fstype
}

function get_fstype() {
  RESULT=$(menu_menu "Filesystem Selection Menu"           \
    "Please select what filesystem to use for $PARTITION"  \
    "ext2"      "Second Extended file system"              \
    "ext3"      "Second Extended journaling file system"   \
    "reiserfs"  "Reiserfs journaling file system"          \
    "xfs"       "XFS journaling file system"               \
    "jfs"       "JFS journaling file system"               \
    "swap"      "Swap partition"
    "custom"    "your call") ||
  {
    STATE=get_part
    return 0
  }
  FSTYPE=$RESULT
  MKFSCMD="$(mkfs_command $FSTYPE $PARTITION)"
  STATE=confirm
}

function confirm() {
  RESULT=$(menu_menu "Confirmation Menu" \
    "Do you want to run the following command:
$MKFSCMD"
    "doit" "Energize!"
    "modify" "Let me edit that line") ||
  {
    STATE=get_fstype
    return 0
  }
  if [[ $RESULT == doit ]] ;then
    STATE=result
  else
    STATE=tunecmd
  fi
}

function tunecmd() {
  RESULT=$(menu_inputbox "Alter command" \
           "Alter the command below whatever way you like.
It will be executed as if typed on the command line." \
           "$MKFSCMD") ||
  {
    STATE=get_fstype
    return 0
  }
  MKFSCMD=$RESULT
  STATE=confirm
}

function result() {
  echo "Creating filesystem..."
  eval "$MKFSCMD" 2>&1 | tee /tmp/mkfs.out
  rc=$?
  if [[ $rc == 0 ]] ;then
    menu_message "Successful mkfs" \
      "Command ran successfully. Output was:
$(cat /tmp/mkfs.out)"
    STATE=get_partition
  else
    RESULT=$(menu_menu "mkfs failed" \
         "Command failed with exit status $rc. Output was:
$(cat /tmp/mkfs.out)" \
         "edit" "Edit command and retry" \
         "return" "Return to partition menu")
    if [[ $RESULT == "return" ]] ;then
      STATE=get_partition
    else # return or "back"
      STATE=tunecmd
    fi
  fi
}

function finish() {
  enchant_setnext
  exit $EXIT_OK
}

menu_loop
