#!/bin/bash
#-------------------------------------------------------------------------------
##
##=head1 SYNOPSIS
##
##  Function and variable definitions for the wards.
##
##=head1 COPYRIGHT
##
##  Copyright 2010 by the Cauldron Team
##
##=head1 FUNCTIONS
##
##=over 4
##
#-------------------------------------------------------------------------------

# set LC_COLLATE to C so we don't get affected by the user's locale
# when grepping, sorting, etc.
export LC_COLLATE="C"

# ensure that WARD_PATH has a value
WARD_PATH="${WARD_PATH:-$(dirname $0)}"

###
# TODO: these paths should not be hardcoded in the future
###
# load liberror (this is not optional)
if ! . "$WARD_PATH/../lib/liberror"
then
  echo "error: could not load $WARD_PATH/../lib/liberror"
  exit 1
fi

# load libcolor (there should be an option for this later)
if ! . "$WARD_PATH/../lib/libcolor"
then
  echo "error: could not load $WARD_PATH/../lib/libcolor"
  exit 1
fi

#-------------------------------------------------------------------------------
## @param -p base path to sources (optional)
## @param -d base path to definition file (optional)
## @param definition file (required)
## @param source1 [source2 source3...] (required)
##
## Tests whether any variables used in source1 (source2, source3, etc.) are
## defined in the definition file. Any variables that are used but not defined
## in the definition file are output via libcolor_warn, preceded by the file
## they were found in via libcolor_file. Both base paths default to the current
## working directory if not supplied.
##
#-------------------------------------------------------------------------------
function ward_global_variables() {
  local fpath="."
  local dpath="."
  local defines=""
  local file=""

  # process any optional parameters
  while [[ "${1:0:1}" == "-" ]]
  do
    case "$1" in
      "-p")
        fpath="${2%/}"
        shift 2
        ;;
      "-d")
        dpath="${2%/}"
        shift 2
        ;;
      *)
        libcolor_error "error: invalid function parameter $1"
        echo ""
        liberror_die $ERR_FATAL
        ;;
    esac
  done

  # make sure we have a good source file path component
  if [[ ! -d "$fpath" ]]
  then
    echo "error: source file search path not recognized"
    liberror_die $ERR_FATAL
  fi

  # make sure we have a good definition file path component
  if [[ ! -d "$dpath" ]]
  then
    echo "error: variable definition file search path not recognized"
    liberror_die $ERR_FATAL
  fi

  # get the defines file, then drop it from the argument list
  defines="$1"
  shift

  # if defines is not given with an absolute path, add the base path prefix
  [[ "${defines:0:1}" != "/" ]] && defines="$dpath/$defines"

  # make sure the defines file exists, otherwise we can't check anything
  if [[ ! -f "$defines" ]]
  then
    echo "error: definition file not found"
    liberror_die $ERR_FATAL
  fi

  while [[ $# -gt 0 ]]
  do
    file="$1"
    shift

    # if file is not given with an absolute path, add the base path prefix
    [[ "${file:0:1}" != "/" ]] && file="$fpath/$file"

    [[ -f "$file" ]] || continue

    # as per the API specification, all global variables are required to be
    # uppercase, and must begin with a letter, containing only letters,
    # underscores, and trailing numbers
    for search in $(grep -o '${\?[A-Z][A-Z_]*[0-9]*' "$file" | sed 's/^\${\?//' | sort -u)
    do
      if ! grep -q "$search=" "$defines"
      then
        echo "$(libcolor_file $file): $(libcolor_warn $search)"
      fi
    done
  done
}

#-------------------------------------------------------------------------------
## @param -p base path to sources (optional)
## @param error code file (required)
##
## Ensures that the error code file itself is properly defined, making sure that
## for every error code there is a matching error message, and for every error
## message there is a matching error code. The base path defaults to the current
## working directory if not supplied.
##
#-------------------------------------------------------------------------------
function ward_error_codes() {
  local path="."
  local errorcodes=""
  local leader="       "
  local codes=()
  local msgcode=""
  local count=""

  # process any optional parameters
  while [[ "${1:0:1}" == "-" ]]
  do
    case "$1" in
      "-p")
        path="${2%/}"
        shift 2
        ;;
      *)
        libcolor_error "error: invalid function parameter $1"
        echo ""
        liberror_die $ERR_FATAL
        ;;
    esac
  done

  # make sure we have a good errorcodes file path component
  if [[ ! -d "$path" ]]
  then
    echo "error: error code file search path not recognized"
    liberror_die $ERR_FATAL
  fi

  errorcodes="$1"

  # if errorcodes is not given with an absolute path, add the base path prefix
  [[ "${errorcodes:0:1}" != "/" ]] && errorcodes="$path/$errorcodes"

  # make sure the defines file exists, otherwise we can't check anything
  if [[ ! -f "$errorcodes" ]]
  then
    libcolor_error "error: error code file "
    libcolor_file "$errorcodes"
    libcolor_error " not found"
    echo ""
    liberror_die $ERR_FATAL
  fi

  if ! source "$errorcodes" 2 > /dev/null
  then
    libcolor_error "error: could not source error code file "
    libcolor_file "$errorcodes"
    echo ""
  fi

  # get the list of defined error codes
  codes=( $(grep -o '^ERR_[A-Z_]\+[0-9]*' "$errorcodes" | grep -v 'ERR_MSGS') )

  # test if the number of messages matches the number of error codes
  if [[ "${#codes[@]}" -ne "${#ERR_MSGS[@]}" ]]
  then
    libcolor_error "error: "
    libcolor_error "number of error codes not equal to number of messages"
    echo ""
    libcolor_error "${leader}codes:    ${#codes[@]}"
    echo ""
    libcolor_error "${leader}messages: ${#ERR_MSGS[@]}"
    echo ""
  fi

  # for every error code defined, make sure there is a corresponding message
  for ((count=0; "$count" < "${#codes[@]}"; count++))
  do
    if ! grep -q "${codes[count]}\$" "$errorcodes"
    then
      libcolor_error "error: ${codes[count]}: "
      libcolor_error "DEFINED but has no corresponding message"
      echo ""
    fi
  done

  # for every error message defined, make sure there is a corresponding code
  for ((count=0; "$count" < "${#ERR_MSGS[@]}"; count++))
  do
    msgcode=$(grep "${ERR_MSGS[count]}.*# " "$errorcodes" | sed 's/.*# //')

    if ! grep -q "^${msgcode}=" "$errorcodes"
    then
      libcolor_error "error: $msgcode: "
      libcolor_error "NOT DEFINED but message is"
      echo ""
    fi
  done
}

#-------------------------------------------------------------------------------
## @param -p base path to sources (optional)
## @param -l base path to libraries (optional)
## @param source1 [source2 source3...] (required)
##
## Tests whether any functions used in source1 (source2, source3, etc.) are
## defined. Any functions that are used but not defined in the corresponding
## definition file are output via libcolor_warn, preceded by the file they were
## found in via libcolor_file. Both base paths default to the current working
## directory if not supplied.
##
#-------------------------------------------------------------------------------
function ward_functions() {
  local fpath="."
  local lpath="."
  local file=""
  local prefix=""
  local list=""
  local matched=""

  # make sure we have a minimum number of arguments
  if [[ $# -lt 2 ]]
  then
    echo "error: improper number of arguments"
    liberror_die $ERR_FATAL
  fi

  # process any optional parameters
  while [[ "${1:0:1}" == "-" ]]
  do
    case "$1" in
      "-p")
        fpath="${2%/}"
        shift 2
        ;;
      "-l")
        lpath="${2%/}"
        shift 2
        ;;
      *)
        libcolor_error "error: invalid function parameter $1"
        echo ""
        liberror_die $ERR_FATAL
        ;;
    esac
  done

  # make sure we have a good source file path component
  if [[ ! -d "$fpath" ]]
  then
    echo "error: source file search path not recognized"
    liberror_die $ERR_FATAL
  fi

  # make sure we have a good library path component
  if [[ ! -d "$lpath" ]]
  then
    echo "error: library search path not recognized"
    liberror_die $ERR_FATAL
  fi

  while [[ $# -gt 0 ]]
  do
    file="$1"
    shift

    # if file is not given with an absolute path, add the base path prefix
    [[ "${file:0:1}" != "/" ]] && file="$fpath/$file"

    [[ -f "$file" ]] || continue

    list=($(grep -o "^[ ]*[a-z]\+_[a-z_]\+" "$file" | sed 's/^ *//' | sort -u))
    # for each called function, check prefix by prefix
    for function in "${list[@]}"
    do
      # check if the function is defined somewhere in the file it came from
      grep -q "^function $function() {" "$file" && continue

      # seed the defines variable for the loop below
      local mangle="$function"

      # check against the prefixes, one at a time
      while $(echo $mangle | grep -q '^[a-z]\+_[a-z_]\+')
      do
        prefix="${mangle%%_*}"
        [[ "$prefix" == "enchant" ]] && prefix="enchantment"

        # check for the function in a library file matching the prefix
        if [[ -f "$lpath/lib$prefix" ]]
        then
          if grep -q "^function $function() {" "$lpath/lib$prefix"
          then
            matched="yes"
            break
          fi
        elif [[ -f "$lpath/lib.$prefix" ]]
        then
          if grep -q "^function $function() {" "$lpath/lib.$prefix"
          then
            matched="yes"
            break
          fi
        fi

        # no match yet, strip the prefix and repeat
        mangle="${mangle#*_}"
      done

      # if the function isn't defined in the corresponding file, warn the user
      if [[ -z "$matched" ]]
      then
        echo "$(libcolor_file $file): $(libcolor_warn $function)"
      fi
    done
  done
}

#-------------------------------------------------------------------------------
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#-------------------------------------------------------------------------------

# vim:ai:tw=80:tabstop=2:softtabstop=2:shiftwidth=2:expandtab
