#!/bin/bash
#-------------------------------------------------------------------------------
##
##=head1 SYNOPSIS
##
##  Common functions and variables for different installers
##
##=head1 DESCRIPTION
##
##  This file provides common function and variable definitions for
##  the different types of installers that can be included on an ISO.
##  This file is meant to be sourced by the different installers,
##  so this file should not be run directly. This file, as well as
##  the installer which sources this file, is meant to be called from
##  inside the ISO during the actual install onto the target system.
##
##=head1 COPYRIGHT
##
##  Copyright 2009 The Cauldron Team
##
##=head1 FUNCTIONS
##
##=over 4
##
#-------------------------------------------------------------------------------

ENCHANT_NULL="/dev/null"

#-------------------------------------------------------------------------------
##
## Used only when checking initialization of the library and a fatal error
## occurs. Afterwards, functions from liberror are used instead.
##
#-------------------------------------------------------------------------------
function enchant_fatal_error() {
  echo "$1"
  exit 1
}

#-------------------------------------------------------------------------------
# liberror includes
#-------------------------------------------------------------------------------
. "$ENCHANT_BASE/liberror" ||
  enchant_fatal_error "error: cannot load base libraries!"

# load enchantment error code and message defines
. "$ENCHANT_LIBS/errorcodes" ||
  enchant_fatal_error "error: cannot load enchantment libraries!"

# drop enchant_fatal_error if liberror was successfully loaded
unset enchant_fatal_error

#-------------------------------------------------------------------------------
## @param library name to load (no path, just basename)
##
## Loads the library given as the first argument. liberror_check_fatal_error is
## called to check if there was a problem loading the library, and if there was
## it will print a corresponding error message and then exit with the error
## $ERR_LOAD_LIBRARY.
##
#-------------------------------------------------------------------------------
function enchant_load_library() {
  local lib="$1"

  . "$ENCHANT_LIBS/$lib" 2>$ENCHANT_NULL
  liberror_check_fatal_error
}

#-------------------------------------------------------------------------------
# enchant includes
#-------------------------------------------------------------------------------
enchant_load_library "lib.potion"

#-------------------------------------------------------------------------------
# function definitions
#-------------------------------------------------------------------------------
#-------------------------------------------------------------------------------
##
## Determines whether we should attempt to load libcolor
##
#-------------------------------------------------------------------------------
function enchant_color() {
  # if ENCHANT_COLOR was set to null
  if [[ -z $ENCHANT_COLOR ]]
  then
    # check if nocolor wasn't passed on the boot command-line
    if ! grep -q 'nocolor' /proc/cmdline
    then
      # we want color
      return 0
    fi
  else
    # if ENCHANT_COLOR specifically set to yes
    if [[ "$ENCHANT_COLOR" == "yes" ]]
    then
      # we want color
      return 0
    fi
  fi

  # for all other cases, we don't want color
  return 1
}

#-------------------------------------------------------------------------------
##
## @param kernel
## @param linux_version
##
## Copies the kernel and it's associated modules from the ISO to the TARGET
## system. Requires that / and /boot on the TARGET system are mounted. It is
## capable of copying multiple kernels, but for now the ISO will only have 1
## kernel.
##
#-------------------------------------------------------------------------------
function enchant_copy_kernel() {
  local KERNEL="$1"
  local LINUX_VER="$2"

  # copy the kernel over
  cp "$ENCHANT_ISO/boot/$KERNEL" "$ENCHANT_TARGET/boot/" ||
    return $ERR_KERNEL

  # copy the modules over
  cp --parents -r "$ENCHANT_ISO/lib/modules/$LINUX_VER"/* "$ENCHANT_TARGET/" ||
    return $ERR_KERNEL_MODULES

  # make sure that the proper dep info is generated on the target system
  depmod -a -b "$ENCHANT_TARGET/lib/modules/$LINUX_VER" "$LINUX_VER" ||
    return $ERR_KERNEL_DEPMOD

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Sets the installer system to a sane, known initial state. Should only be
## called when first entering the installer system or ISO.
##
#-------------------------------------------------------------------------------
function enchant_prepare() {
  # this initializes the file which holds the current step
  mkdir -p "$ENCHANT_TMP" || return $ERR_PREPARE
  echo 'init' > "$ENCHANT_STATUS" || return $ERR_PREPARE

  # the next lines are to init the history files
  mkdir -p "$ENCHANT_TMP/history" || return $ERR_PREPARE
  cat < $ENCHANT_NULL > "$ENCHANT_BACK" || return $ERR_PREPARE
  cat < $ENCHANT_NULL > "$ENCHANT_FORWARD" || return $ERR_PREPARE

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Cleans up the tmp directories and such forth
##
#-------------------------------------------------------------------------------
function enchant_cleanup() {
  rm -fr "$ENCHANT_TMP" || return $ERR_CLEANUP

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Returns a list of all modules recognized for the current installation, pruned
## of duplicates and the special "error" module.
##
#-------------------------------------------------------------------------------
function enchant_get_modules() {
  local output=( )
  local module

  for module in $(cut -d: -f1 "$ENCHANT_DATA/modules")
  do
    if [[ "$module" != "error" ]]
    then
      if ! $(echo ${output[*]} | grep -q "$module")
      then
        output=( ${output[*]} "$module" )
      fi
    fi
  done

  echo ${output[@]}
}

#-------------------------------------------------------------------------------
##
## Determines and returns the current module in the installation procedure.
##
#-------------------------------------------------------------------------------
function enchant_get_current() {
  [[ -z $ENCHANT_STATUS ]] && return $ERR_GET_CURRENT

  cat "$ENCHANT_STATUS" || return $ERR_GET_CURRENT

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## @param step
##
## Sets the current module of the installer to be the step passed as an
## argument. Stores the current module to the back history before setting it to
## the new module.
##
#-------------------------------------------------------------------------------
function enchant_set_current() {
  local module=$1

  if ! $(enchant_get_modules | grep -q $module)
  then
    return $ERR_SET_CURRENT
  fi

  enchant_module_exit || return $ERR_MODULE_EXIT

  # if the max history size has been reached, then we drop the oldest item
  if [[ "$(wc -l < $ENCHANT_BACK)" -ge "$ENCHANT_HISTORY" ]]
  then
    sed -i '1d' "$ENCHANT_BACK" || return $ERR_SET_CURRENT
  fi

  # copy the current module to the back history
  echo "$module" >> "$ENCHANT_BACK" || return $ERR_SET_CURRENT

  # check the installation state
  enchant_check_state || return $ERR_CHECK_STATE

  # set the current module
  echo "$module" > "$ENCHANT_STATUS" || return $ERR_SET_CURRENT

  enchant_module_enter || return $ERR_MODULE_ENTER

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Determines and returns the next module in the installation procedure.
##
#-------------------------------------------------------------------------------
function enchant_get_next() {
  local step
  step="$(grep -m1 \"^$(enchant_get_current):\" $ENCHANT_DATA/modules)" ||
    return $ERR_GET_NEXT

  step="$(echo $step | cut -d: -f2)" || return $ERR_GET_NEXT

  if [[ -z $step ]]
  then
    echo "error"
    return $ERR_GET_NEXT
  fi

  echo $step

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Sets the current module to the next module in the installation procedure.
##
#-------------------------------------------------------------------------------
function enchant_set_next() {
  local module

  # get next step
  module="$(enchant_get_next)" || return $ERR_SET_NEXT

  # save new status
  enchant_set_step "$module" || return $ERR_SET_NEXT

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Determines and returns the previous module in the installation procedure.
##
#-------------------------------------------------------------------------------
function enchant_get_prev() {
  local step

  # get the current step
  step="$(enchant_get_current)" || return $ERR_GET_PREV

  step="$(grep -m1 \":$step$\" $ENCHANT_DATA/order)" || return $ERR_GET_PREV

  step="$(echo $step | cut -d: -f1)" || return $ERR_GET_PREV

  if [[ -z $step ]]
  then
    echo "error"
    return $ERR_GET_PREV
  fi

  echo "$step"

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Sets the current module to the previous module in the installation procedure.
##
#-------------------------------------------------------------------------------
function enchant_set_prev() {
  local module

  # get the current step
  module="$(enchant_get_prev)" || return $ERR_SET_PREV

  enchant_set_current "$module" || return $ERR_SET_PREV

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Moves the installer backward in its history (like the back button on a
## web browser.
##
## when you go back, you store/save the forward pages
##
#-------------------------------------------------------------------------------
function enchant_back() {
  # if the back history is empty, then we can't go back
  [[ "$(wc -l < $ENCHANT_BACK)" -eq 0 ]] && return $ERR_BACK

  # if the max forward history size has been reached
  if [[ "$(wc -l < $ENCHANT_FORWARD)" -ge $ENCHANT_HISTORY ]]
  then
    # then we drop the oldest item from the forward history
    sed -i '1d' "$ENCHANT_FORWARD" || return $ERR_BACK
  fi

  # copy the current status to the forward history, so we can go forward to
  # where we are after we jump back
  enchant_get_current >> "$ENCHANT_FORWARD" || return $ERR_BACK

  # set the current step to be the one we are jumping to
  tail -n 1 "$ENCHANT_BACK" > "$ENCHANT_STATUS" || return $ERR_BACK

  # remove the step we jumped to from the back history
  sed -i '$d' "$ENCHANT_BACK" || return $ERR_BACK

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Moves the installer forward in its history (like the forward button on a
## web browser.
##
## when you go forward, you store/save the back pages
##
#-------------------------------------------------------------------------------
function enchant_forward() {
  # if the forward history is empty, then we can't go forward
  [[ "$(wc -l < $ENCHANT_FORWARD)" -eq 0 ]] && return $ERR_FORWARD

  # if the max back history size has been reached
  if [[ "$(wc -l < $ENCHANT_BACK)" -ge "$ENCHANT_HISTORY" ]]
  then
    # then we drop the oldest item from the back history
    sed -i '1d' "$ENCHANT_BACK" || return $ERR_FORWARD
  fi

  # copy the current status to the back history, so we can go back to where we
  # are after we jump forward
  enchant_get_current >> "$ENCHANT_BACK" || return $ERR_FORWARD

  # set the current step to be the one we are jumping to
  tail -n 1 "$ENCHANT_FORWARD" > "$ENCHANT_STATUS" || return $ERR_FORWARD

  # remove the step we jumped to from the forward history
  sed -i '$d' "$ENCHANT_FORWARD" || return $ERR_FORWARD

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Returns the number of the current module to perform during the installation.
## Expects $ENCHANT_INSTALLER to be set by the installer which is calling this
## function, and for that installer to have a 'modules' file (see the
## implementation of the shell installer for an example).
##
#-------------------------------------------------------------------------------
function enchant_get_num() {
  local num="$(grep -n -m1 \"^$(enchant_get_current):\" $ENCHANT_INSTALLER/modules)"

  if [[ -z $num ]]
  then
    return $ERR_GET_NUM
  fi

  echo "$num" | cut -d: -f1 || return $ERR_GET_NUM

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Returns the total number of modules to perform during the installation
##
#-------------------------------------------------------------------------------
function enchant_get_total() {
  local total="$(enchant_get_modules | wc -l)"

  if [[ "$total" -eq 0 || -z $total ]]
  then
    return $ERR_TOTAL_ZERO
  fi

  echo "$total"

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Processes the module entry functions. This is used to provide extra
## functionality upon entering a module (usually preparatory work, like creating
## module-specific temp files, etc.)
##
#-------------------------------------------------------------------------------
function enchant_module_enter() {
  local module="$(cat $ENCHANT_STATUS)"
  local script=""

  for script in "$ENCHANT_MODULES/$module/enter"/*
  do
    if [[ -f "$script" ]]
    then
      /bin/bash "$script" || return $ERR_MODULE_SCRIPT
    fi
  done

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Processes the module exit functions. This is used to provide extra
## functionality upon exiting a module, usually things like writing data to the
## module's temp files, etc.
##
#-------------------------------------------------------------------------------
function enchant_module_exit() {
  local module="$(cat $ENCHANT_STATUS)"
  local script=""

  for script in "$ENCHANT_MODULES/$module/exit"/*
  do
    if [[ -f "$script" ]]
    then
      /bin/bash "$script" || return $ERR_MODULE_SCRIPT
    fi
  done

  return $ERR_OK
}

#-------------------------------------------------------------------------------
## @param potion to process for
##
## Processes the module potion functions. This is used to do automated installs
## using pre-made potions (from previous installs or composed ahead of time). It
## runs scripted versions of what the user would have done manually in each
## module.
##
#-------------------------------------------------------------------------------
function enchant_module_potion() {
  local module="$(cat $ENCHANT_STATUS)"
  local potion="$1"
  local script=""

  [[ -d "$potion" ]] || $ERR_DIR_NOT_FOUND

  for script in "$ENCHANT_MODULES/$module/potion"/*
  do
    if [[ -f "$script" ]]
    then
      /bin/bash "$script" "$potion" || return $ERR_MODULE_SCRIPT
    fi
  done

  return $ERR_OK
}


#-------------------------------------------------------------------------------
##=back
##
##=head1 LICENSE
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#-------------------------------------------------------------------------------

# vim:ai:tw=80:tabstop=2:softtabstop=2:shiftwidth=2:expandtab
