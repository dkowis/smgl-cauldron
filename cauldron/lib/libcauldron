#!/bin/bash
#-------------------------------------------------------------------------------
##
##=head1 SYNOPSIS
##
##  libcauldron is a set of functions used internally by the cauldron script
##
##=head1 COPYRIGHT
##
##  Copyright 2009 by the Cauldron Team
##
##=head1 FUNCTIONS
##
##=over 4
##
#-------------------------------------------------------------------------------

# set LC_COLLATE to C so we don't get affected by the user's locale
# when grepping, sorting, etc.
export LC_COLLATE="C"

# shorthand and non-hardcoded /dev/null for output dumping
CAULDRON_NULL="${CAULDRON_NULL:-/dev/null}"

#-------------------------------------------------------------------------------
##
## Used only when checking initialization of the library and a fatal error
## occurs. Afterwards, functions from liberror are used instead.
##
#-------------------------------------------------------------------------------
function cauldron_fatal_error() {
  echo "$1"
  exit 1
}

#-------------------------------------------------------------------------------
##
## error handling library includes - load these first!
##
#-------------------------------------------------------------------------------
. "$CAULDRON_COMMON/liberror" 2>"$CAULDRON_NULL" ||
  cauldron_fatal_error "error: cannot load base library liberror"

# load cauldron error code and message defines
. "$CAULDRON_LIBS/errorcodes" 2>"$CAULDRON_NULL" ||
  cauldron_fatal_error "error: cannot load cauldron error codes"

. "$CAULDRON_COMMON/libcolor" 2>"$CAULDRON_NULL" ||
  cauldron_fatal_error "error: cannot load base library libcolor"

# test/set whether color output should be enabled
[[ $CAULDRON_COLOR != "yes" ]] && LIBCOLOR_NOCOLOR="yes"

# drop cauldron_fatal_error if liberror was successfully loaded
unset cauldron_fatal_error

#-------------------------------------------------------------------------------
## @param library name to load (no path, just basename)
##
## Loads the library given as the first argument. liberror_check_fatal is
## called to check if there was a problem loading the library, and if there was
## it will print a corresponding error message and then exit with the error
## $ERR_LOAD_LIBRARY.
##
#-------------------------------------------------------------------------------
function cauldron_load_library() {
  local lib="$1"

  . "$CAULDRON_LIBS/$lib" 2>$CAULDRON_NULL
  liberror_check_fatal "cannot load library $lib"
}

#-------------------------------------------------------------------------------
# cauldron includes
#-------------------------------------------------------------------------------
cauldron_load_library "lib.sorcerous"
cauldron_load_library "lib.chroot"
cauldron_load_library "lib.init"
cauldron_load_library "lib.toolchain"

#-------------------------------------------------------------------------------
## @param color state [yes or no] (optional)
##
## Wrapper function that handles setting the color state in libcolor. Possible
## values for the color state parameter are 'yes' or 'no' (without the quotes).
## If the parameter isn't supplied, then it defaults to whatever CAULDRON_COLOR
## is set to.
##
#-------------------------------------------------------------------------------
function cauldron_color() {
  local color="${1:-$CAULDRON_COLOR}"

  [ "$1" = "no" ] && LIBCOLOR_NOCOLOR="yes"
}

#-------------------------------------------------------------------------------
## @param cleanfile
##
## Cleans out unneeded files that were used to generate the ISO, but should
## not be present on the final ISO system. cleanfile is a file that lists paths
## to remove (absolute paths, relative to a chroot of the iso), one file/path
## per line.
##
#-------------------------------------------------------------------------------
function cauldron_clean_iso_system() {
  local cleanfile="$1"

  [[ -z "$cleanfile" ]] && return $ERR_CLEAN_FILE

  [[ -z "$CAULDRON_CHROOT" ]] && return $ERR_CHROOT_INIT

  for i in $(sort -r $cleanfile)
  do
    if [[ -d "$i" ]]
    then
      "$CAULDRON_CMD_OUTPUT[@]}" "Attempting to remove directory $i..."
      cauldron_chroot rmdir "$i" || return $ERR_CLEAN_DIR
    else
      "$CAULDRON_CMD_OUTPUT[@]}" "Deleting $i"
      cauldron_chroot rm "$i" || return $ERR_CLEAN_FILE
    fi
  done

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Packages the sys directory into a compressed tarball to be placed in the iso
## filesystem as system.tar.bz2. Relies on the fact that
## CAULDRON_CMD_ARCHIVE_SYS will add a file suffix to the CAULDRON_SYS_NAME
## base filename.
##
#-------------------------------------------------------------------------------
function cauldron_package_sys() {
  "${CAULDRON_CMD_ARCHIVE_SYS[@]}" || return $ERR_SYS_PACKAGE

  "${CAULDRON_CMD_COMPRESS[@]}" "$CAULDRON_BUILD/$CAULDRON_SYS_NAME".* ||
    return $ERR_SYS_COMPRESS

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Builds the ISO filesystem using the generated ISO data and the filename
## set in the cauldron config file.
##
#-------------------------------------------------------------------------------
function cauldron_package_iso() {
  "${CAULDRON_CMD_MKISO[@]}" || return $ERR_ISO_PACKAGE

  "${CAULDRON_CMD_COMPRESS[@]}" "$CAULDRON_ISO_NAME" || return $ERR_ISO_COMPRESS

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Sources the enchantment config files in the build chroot so that we can
## obtain (and modify if the user so wishes) the paths where we will store the
## enchantment files (libraries, installers, install modules, etc.) on the ISO.
##
#-------------------------------------------------------------------------------
function cauldron_source_enchantment() {
  local host_enchant_config="$CAULDRON_HOST/etc/cauldron/enchantment/config"
  local enchant_config="$CAULDRON_BUILD/etc/enchantment/config"
  local enchant_lconfig="$CAULDRON_BUILD/etc/enchantment/local/config"

  # make sure the ISO has the enchantment configs first
  # if, we need to copy them (they are required for the ISO)
  if [[ ! -f "$enchant_config" ]]
  then
    "${CAULDRON_CMD_CP_FORCE[@]}" "$host_enchant_config" "$enchant_config" ||
      liberror_die $ERR_ENCHANT_CONFIG
  fi

  # set ENCHANT_ISO_PATH before sourcing the enchantment configs so all the
  # enchantment variables used by cauldron will be relative to the cauldron
  # build chroot
  ENCHANT_ISO_PATH="$CAULDRON_BUILD"

  # source the enchantment config to make sure we get the paths correct
  . "$enchant_config" 2>$CAULDRON_NULL ||
    liberror_die $ERR_ENCHANT_CONFIG
  # try to source the local config, but don't die if it doesn't exist
  . "$enchant_lconfig" 2>$CAULDRON_NULL
}

#-------------------------------------------------------------------------------
##
## Adds the given installer(s) listed in $CAULDRON_INSTALLERS to the ISO system.
## The user can then choose the installer either at boot-time or run-time.
##
## The installer(s) can currently be shell or menu (future: X?). In theory it
## should support any installer, as long as it's packaged in its own directory
## and the name of that dir is included in CAULDRON_INSTALLERS, and the binary
## to execute for that installer is named enchantment* (i.e., enchantment
## (shell) or enchantment-menu). This behavior may change in the future though.
##
#-------------------------------------------------------------------------------
function cauldron_add_installers() {
  local installer=""

  # no need to return error if cauldron_source_enchantment fails, because it
  # runs liberror_die itself on error, which causes an exit
  [[ -z $ENCHANT_DATA ]] && cauldron_source_enchantment

  # make sure CAULDRON_BUILD/ENCHANT_DATA exists
  "${CAULDRON_CMD_MKDIR[@]}" "$ENCHANT_DATA" || return $ERR_INSTALLER_DIR

  for installer in $CAULDRON_INSTALLERS
  do
    "${CAULDRON_CMD_CP_RECURSE[@]}" \
      "$CAULDRON_LIBS/enchantment/$installer" \
      "$ENCHANT_DATA/" ||
        return $ERR_COPY_INSTALLER
    "$CAULDRON_CMD_SYMLINK_FORCE[@]}" \
      "$ENCHANT_DATA/$installer"/bin/enchantment* \
      "$CAULDRON_BUILD/usr/sbin/" ||
        return $ERR_LINK_INSTALLER
  done

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## This creates the CAULDRON_BUILD directory, and copies sorcery and
## cauldron files into it. It also configures the CAULDRON_BUILD
## sorcery as necessary (i.e. ensures that CLEAN_SOURCE="off") for
## sanity purposes
##
#-------------------------------------------------------------------------------
function cauldron_prepare() {
  # ensure that the build dir exists
  "${CAULDRON_CMD_MKDIR[@]}" "$CAULDRON_BUILD"

  # ensure CAULDRON_BUILD/etc exists
  "${CAULDRON_CMD_MKDIR[@]}" "$CAULDRON_BUILD/etc"

  # copy the host's resolv.conf in order to dl sources from the net
  "${CAULDRON_CMD_CP[@]}" \
    "$CAULDRON_RESOLV" \
    "$CAULDRON_BUILD/etc/resolv.conf" ||
      return $ERR_RESOLV

  # prepare chroots to $CAULDRON_BUILD
  cauldron_chroot_init || return $?

  # install sorcery into the build dir
  if [[ -z cauldron_sorcerous_install ]]
  then
    cauldron_load_library lib.sorcerous
  fi
  cauldron_sorcerous_install "$CAULDRON_BUILD" || return $ERR_SORCEROUS_INSTALL

  # cauldron is a spell
  # there is a spoon
  cauldron_chroot "${CAULDRON_CMD_CAST[@]}" cauldron || return $ERR_CHROOT_CAST

  # clean up the chroot
  cauldron_chroot_done || return $?

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Cleans up the tmp directories and such forth
##
#-------------------------------------------------------------------------------
function cauldron_cleanup() {
  # if the user wants everything cleaned, kill the build directory
  if [[ "$CAULDRON_CLEAN" == "yes" ]]
  then
    "${CAULDRON_CMD_RM_RECURSE_FORCE[@]}" "$CAULDRON_BUILD" ||
      return $ERR_CLEANUP_BUILD
  fi

  # kill the temp directory
  "${CAULDRON_CMD_RM_RECURSE_FORCE[@]}" "$CAULDRON_TMP" || return $ERR_CLEANUP_TMP

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#-------------------------------------------------------------------------------

# vim:ai:tw=80:tabstop=2:softtabstop=2:shiftwidth=2:expandtab
