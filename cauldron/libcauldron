#!/bin/bash
#-------------------------------------------------------------------------------
##
##=head1 SYNOPSIS
##
##  libcauldron is a set of functions used internally by the cauldron script
##
##=head1 COPYRIGHT
##
##  Copyright 2009 by the Cauldron Team
##
##=head1 FUNCTIONS
##
##=over 4
##
#-------------------------------------------------------------------------------

# shorthand and non-hardcoded /dev/null for output dumping
CAULDRON_NULL="/dev/null"

#-------------------------------------------------------------------------------
##
## Used only when checking initialization of the library and a fatal error
## occurs. Afterwards, functions from liberror are used instead.
##
#-------------------------------------------------------------------------------
function cauldron_fatal_error() {
  echo "$1"
  exit 1
}

#-------------------------------------------------------------------------------
##
## liberror includes - load these first!
##
#-------------------------------------------------------------------------------
. "$CAULDRON_BASE/liberror" 2>$CAULDRON_NULL ||
  cauldron_fatal_error "error: cannot load base library liberror"

# load cauldron error code and message defines
. "$CAULDRON_LIBS/errorcodes" 2>$CAULDRON_NULL ||
  cauldron_fatal_error "error: cannot load cauldron error codes"

. "$CAULDRON_BASE/libcolor" 2>$CAULDRON_NULL ||
  cauldron_fatal_error "error: cannot load base library libcolor"

# test/set whether color output should be enabled
[[ $CAULDRON_COLOR != "yes" ]] && LIBCOLOR_NOCOLOR="yes"

# drop cauldron_fatal_error if liberror was successfully loaded
unset cauldron_fatal_error

#-------------------------------------------------------------------------------
## @param library name to load (no path, just basename)
##
## Loads the library given as the first argument. liberror_check_fatal_error is
## called to check if there was a problem loading the library, and if there was
## it will print a corresponding error message and then exit with the error
## $ERR_LOAD_LIBRARY.
##
#-------------------------------------------------------------------------------
function cauldron_load_library() {
  local lib="$1"

  . "$CAULDRON_LIBS/$lib" 2>$CAULDRON_NULL
  liberror_check_fatal_error
}

#-------------------------------------------------------------------------------
# cauldron includes
#-------------------------------------------------------------------------------
#cauldron_load_library "lib.sorcerous"

cauldron_load_library "lib.chroot"

cauldron_load_library "lib.init"

#cauldron_load_library "lib.toolchain"

#-------------------------------------------------------------------------------
##
## Scans the sorcery archspec files to find the host triplet
##
## Later, this will be used to set the value of HOST_TRIPLE in
## /etc/cauldron/config after the code to write the config file is in
## place
##
#-------------------------------------------------------------------------------
function cauldron_get_host_triple() {
  local arch_spec=""
  local host_triple=""
  local spec=""

  # get the value for the HOST triplet from sorcery archspecs
  for spec in ${CAULDRON_HOST_ARCH_PATH[@]}
  do
    local search="-perm 400 -type f -name $CAULDRON_HOST_ARCH"

    if [[ "$(find --version | grep -q 'version 4\.1\(\.\|$\)')" == 1 ]]
    then
      arch_spec="$(find $spec $search -print 2>$CAULDRON_NULL)"
    else
      arch_spec="$(find -L $spec $search -print 2>$CAULDRON_NULL)"
    fi

    [[ -n "$arch_spec" ]] && break
  done

  host_triple="$(grep 'HOST=' $arch_spec | cut -d = -f 2)"

  echo "$host_triple"
}

#-------------------------------------------------------------------------------
##
## Generates the base toolchain using the HOST information. This is
## done by unpacking the cache file for each spell required for the
## toolchain if it exists. If it does not exist, this may be because
## caching is disabled on the host machine, or perhaps the cache file
## was deleted by accident. Otherwise the spell must be cast within
## a chroot environment in the CAULDRON_BUILD directory.
##
#-------------------------------------------------------------------------------
function cauldron_base_toolchain() {
  local spell=""
  local version=""
  local spell_cache=""
  local host_triple=""
  local ext="$CAULDRON_CACHE_EXTENSION"

  # get the value for HOST_TRIPLE
  host_triple="$(cauldron_get_host_triple)"

  [[ -z "$host_triple" ]] && return $ERR_HOST_TRIPLE

  # grab the list of spells needed as the base tool-chain which will be
  # used to create the cross-compile tool-chain
  for spell in "$CAULDRON_TOOLCHAIN"
  do
    # grab the version for the spell from sorcery's state info
    # on what's installed
    version="$(grep ^$spell $CAULDRON_HSORCERY_PACKAGES | cut -d: -f4)"

    # check if spell found on the system
    if [[ -n "$version" ]]
    then
      # set SPELL_CACHE as shorthand for SPELL-VERSION-HOST_TRIPLE.tar.bz2
      spell_cache="${spell}-${version}-${host_triple}.tar${ext}"

      # check to see if there is already a cache file from sorcery
      # this check could be based on spell-{names,versions} reported by
      # gaze/sorcery/dispel. Mirroring code in dispel might be the best bet,
      # since that has to find the version currently installed anyway.
      if [[ -f "$CAULDRON_HSORCERY_SPOOL/$spell_cache" ]]
      then
        # found a cache file, copy it to the BUILD dir
        cp "$CAULDRON_HSORCERY_SPOOL/$spell_cache" "$CAULDRON_BUILD" ||
          return $ERR_CP_CACHE
      else
        # couldn't find a cache file, so we'll need to build one
        if [[ -z cauldron_build_host_cache_file ]]
        then
          cauldron_load_library "lib.hostcache"
        fi
        cauldron_build_host_cache_file "$spell" ||
          return $ERR_BUILD_CACHE
      fi

      # unpack the cache file, effectively installing
      # the spell into the BUILD dir
      # the unpacking is done against the BUILD dir as the root dir, so
      # this should not touch the HOST filesystem at all
      tar xjf "$CAULDRON_BUILD/$spell_cache" -C "$CAULDRON_BUILD/" ||
        return $ERR_UNPACK_CACHE

      # if the tar was successful, then remove the temporary file
      rm "$CAULDRON_BUILD/$spell_cache" ||
        return $ERR_RM_CACHE
    # the spell is not present on the HOST system
    else
      # cast the spell inside a chroot to get the cache
      cauldron_chroot "$CAULDRON_CAST" "$spell" || return $ERR_CHROOT
    fi
  done

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## This builds the cross-compiler to produce the TARGET binaries.
##
#-------------------------------------------------------------------------------
function cauldron_cross_toolchain() {
  # build the stage 1 tools
  cauldron_configure_toolchain 1 || return $ERR_TOOLCHAIN_STAGE1
  cauldron_chroot "$CAULDRON_CAST" "binutils" || return $ERR_CHROOT_CAST
  cauldron_chroot "$CAULDRON_CAST" "gcc" || return $ERR_CHROOT_CAST

  # build glibc (stage 2)
  cauldron_configure_toolchain 2 || return $ERR_TOOLCHAIN_STAGE2
  cauldron_chroot "$CAULDRON_CAST" "glibc" || return $ERR_CHROOT_CAST

  # rebuild gcc (still stage 1, but this time linked against the
  # cross-glibc
  cauldron_configure_toolchain 1 || return $ERR_TOOLCHAIN_STAGE1
  cauldron_chroot "$CAULDRON_CAST" "gcc" || return $ERR_CHROOT_CAST

  # do a sorcery rebuild inside the BUILD dir to
  # generate the cross-compile tool-chain (stage 3)
  cauldron_configure_toolchain 3 || return $ERR_TOOLCHAIN_STAGE3
  cauldron_chroot "$CAULDRON_REBUILD" || return $ERR_CHROOT_REBUILD
}

#-------------------------------------------------------------------------------
## @param target_spells
##
## Performs cast on the list of spells needed for installation to the target
## system. "target_spells" is a list of spells that will be needed to install
## into the target system from the iso.
##
#-------------------------------------------------------------------------------
function cauldron_build_target_system() {
  local target_spells="$1"
  local spell=""

  # Since we will be installing from the running ISO system instead of a giant
  # tarball, for each spell we only need to make sure that the cache file is
  # available. This will require that the ISO sorcery has caching enabled. The
  # caching should really be turned on from the very beginning though...
  if [[ -z "$ARCHIVE" ]]
  then
    cauldron_sorcerous_load || return $ERR_TARGET_SORCERY
  fi
  [[ "$ARCHIVE" == "off" ]] && return $ERR_ARCHIVE

  for spell in $target_spells
  do
    # Cheap cop-out to get the cache generated - cast the spell to generate the
    # cache, and then dispel it from the system so that it isn't wasting space
    # on the ISO filesystem (any spells cast here should be those not required
    # for the functioning of the ISO itself, only to be installed to the target
    # system).
    cauldron_chroot "$CAULDRON_CAST" "$spell" || return $ERR_CHROOT_CAST
    cauldron_chroot "$CAULDRON_DISPEL" "$spell" || return $ERR_CHROOT_DISPEL
  done

  return $ERR_OK
}

#-------------------------------------------------------------------------------
## @param cleanfile
##
## Cleans out unneeded files that were used to generate the ISO, but should
## not be present on the final ISO system. cleanfile is a file that lists paths
## to remove (absolute paths, relative to a chroot of the iso), one file/path
## per line.
##
#-------------------------------------------------------------------------------
function cauldron_clean_iso_system() {
  local cleanfile="$1"

  [[ -z "$cleanfile" ]] && return $ERR_CLEANFILE

  for i in $(sort -r $cleanfile)
  do
    if [[ -d "$i" ]]
    then
      echo "Attempting to remove directory $i..."
      rmdir "$i" || return $ERR_CLEAN_DIR
    else
      echo "Deleting $i"
      rm "$i" || return $ERR_CLEAN_FILE
    fi
  done

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Builds the ISO filesystem using the generated ISO data and the filename
## set in the cauldron config file.
##
#-------------------------------------------------------------------------------
function cauldron_mkisofs() {
  mkisofs -R \
    -b isolinux/isolinux.bin \
    -c isolinux/boot.cat \
    -no-emul-boot \
    -boot-load-size 4 \
    -boot-info-table \
    -o "$CAULDRON_ISO_NAME" \
    "$CAULDRON_BUILD" ||
      return $ERR_MKISOFS

  if [[ "$CAULDRON_KEEPISO" == "yes" ]] ;
  then
    bzip2 -k "$CAULDRON_ISO_NAME" || return $ERR_COMPRESS_ISO
  else
    bzip2 "$CAULDRON_ISO_NAME" || return $ERR_COMPRESS_ISO
  fi

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Sources the enchantment config files in the build chroot so that we can
## obtain (and modify if the user so wishes) the paths where we will store the
## enchantment files (libraries, installers, install modules, etc.) on the ISO.
##
#-------------------------------------------------------------------------------
function cauldron_source_enchantment() {
  local host_enchant_config="$CAULDRON_HOST/etc/cauldron/enchantment/config"
  local enchant_config="$CAULDRON_BUILD/etc/enchantment/config"
  local enchant_lconfig="$CAULDRON_BUILD/etc/enchantment/local/config"

  # make sure the ISO has the enchantment configs first
  # if, we need to copy them (they are required for the ISO)
  if [[ ! -f "$enchant_config" ]]
  then
    cp -f "$host_enchant_config" "$enchant_config" ||
      liberror_die $ERR_ENCHANT_CONFIG
  fi

  # set ENCHANT_ISO_PATH before sourcing the enchantment configs so all the
  # enchantment variables used by cauldron will be relative to the cauldron
  # build chroot
  ENCHANT_ISO_PATH="$CAULDRON_BUILD"

  # source the enchantment config to make sure we get the paths correct
  . "$enchant_config" 2>$CAULDRON_NULL ||
    liberror_die $ERR_ENCHANT_CONFIG
  # try to source the local config, but don't die if it doesn't exist
  . "$enchant_lconfig" 2>$CAULDRON_NULL
}

#-------------------------------------------------------------------------------
## @param INSTALLER_MODULE
##
## Adds the given installer to the ISO system. The user can then choose this
## installer either at boot-time or run-time, depending on the installer.
## INSTALLER_MODULE is currently one of shell or menu (future: X?). In theory it
## should support any installer, as long as it's packaged in its own directory and
## the name of that dir is passed as the arg. This behavior may change in the
## future though.
##
#-------------------------------------------------------------------------------
function cauldron_add_installers() {
  local installer=""

  # make sure CAULDRON_BUILD/ENCHANT_DATA exists
  mkdir -p "$ENCHANT_DATA" || return $ERR_INSTALLER_DIR

  for installer in $CAULDRON_INSTALLERS
  do
    cp -r "$CAULDRON_LIBS/enchantment/$installer" "$ENCHANT_DATA/" ||
      return $ERR_COPY_INSTALLER

    ln -sf "$ENCHANT_DATA/$installer"/bin/* "$CAULDRON_BUILD/usr/sbin/" ||
      return $ERR_LINK_INSTALLER
  done

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## This creates the CAULDRON_BUILD directory, and copies sorcery and
## cauldron files into it. It also configures the CAULDRON_BUILD
## sorcery as necessary (i.e. ensures that CLEAN_SOURCE="off") for
## sanity purposes
##
#-------------------------------------------------------------------------------
function cauldron_prepare() {
  # ensure that the build dir exists
  mkdir -p "$CAULDRON_BUILD"

  # copy the host's resolv.conf in order to dl sources from the net
  cp -L /etc/resolv.conf "$CAULDRON_BUILD"/etc/resolv.conf ||
    return $ERR_RESOLV

  # install sorcery into the build dir
  if [[ -z cauldron_sorcerous_install ]]
  then
    cauldron_load_library lib.sorcerous
  fi
  cauldron_sorcerous_install "$CAULDRON_BUILD" || return $ERR_SORCERY_INSTALL

  # cauldron is a spell
  # there is a spoon
  cauldron_chroot "$CAULDRON_CAST" cauldron || return $ERR_CHROOT

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## Cleans up the tmp directories and such forth
##
#-------------------------------------------------------------------------------
function cauldron_cleanup() {
  # if the user wants everything cleaned, kill the build directory
  if [[ "$CAULDRON_CLEAN" == "yes" ]]
  then
    rm -fr "$CAULDRON_BUILD" || return $ERR_CLEANUP_BUILD
  fi

  # kill the temp directory
  rm -fr "$CAULDRON_TMP" || return $ERR_CLEANUP_TMP

  return $ERR_OK
}

#-------------------------------------------------------------------------------
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#-------------------------------------------------------------------------------

# vim:ai:tw=80:tabstop=2:softtabstop=2:shiftwidth=2:expandtab
