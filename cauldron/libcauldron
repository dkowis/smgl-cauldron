#!/bin/bash
#-------------------------------------------------------------------------------
##
##=head1 SYNOPSIS
##
##  libcauldron is a set of functions used internally by the cauldron script
##
##=head1 COPYRIGHT
##
##  Copyright 2009 by the Cauldron Team
##
##=head1 FUNCTIONS
##
##=over 4
##
#-------------------------------------------------------------------------------

#-------------------------------------------------------------------------------
# cauldron includes
#-------------------------------------------------------------------------------
. ${BASE_LIBS}/libinit ||
  cauldron_fatal_error "error: cannot load base libraries!"
. ${BASE_LIBS}/liberror ||
  cauldron_fatal_error "error: cannot load base libraries!"
. ${BASE_LIBS}/liberrorcodes ||
  cauldron_fatal_error "error: cannot load base libraries!"

# load cauldron error code and message defines
. ${CAULDRON_LIBS}/errorcodes ||
  cauldron_fatal_error "error: cannot load cauldron libraries!"

#-------------------------------------------------------------------------------
# Sorcery includes
#-------------------------------------------------------------------------------
# Needed for modifying config files
if [[ -e "${SORCERY_LIBS}"/libstate ]]
then
  . "${SORCERY_LIBS}"/libstate
else
  CAULDRON_HOSTSORCERY=0
fi
if [[ -e "${SORCERY_LIBS}"/libtrack ]]
then
  . "${SORCERY_LIBS}"/libtrack
else
  CAULDRON_HOSTSORCERY=0
fi

#-------------------------------------------------------------------------------
##
## Used only when checking initialization of the library and a fatal error
## occurs. Afterwards, functions from liberror should be used instead.
##
#-------------------------------------------------------------------------------
function cauldron_fatal_error() {
  echo $1
  exit $ERR_FATAL
}

#-------------------------------------------------------------------------------
##
## Sources the sorcery config files. Should only be called by
## cauldron_chroot_init.
##
#-------------------------------------------------------------------------------
function cauldron_source_sorcery() {
  local target=$1

  source "$target/etc/sorcery/config" || return $ERR_TARGETSORCERY
  if [[ -e "$target/etc/sorcery/local/config" ]]
  then
    source "$target/etc/sorcery/local/config"
  fi || return $ERR_TARGETSORCERY
}

#-------------------------------------------------------------------------------
##
## Prepares a chroot environment and exports necessary variables
##
#-------------------------------------------------------------------------------
function cauldron_chroot_init() {
  local TARGET="${1:-$CAULDRON_BUILD}"

  if [[ "$CAULDRON_CHROOTINIT" -ne 1 ]]
  then
    mount --bind "$HOSTPATH"/dev "$TARGET"/dev || ret=$ERR_CHROOTINIT
    mount --bind "$HOSTPATH"/dev/pts "$TARGET"/dev/pts || ret=$ERR_CHROOTINIT
    mount --bind "$HOSTPATH"/proc "$TARGET"/proc || ret=$ERR_CHROOTINIT
    cauldron_source_sorcery "$TARGET" || return $ERR_TARGETSORCERY
    export CAULDRON_CHROOTINIT=1
    export CAULDRON_CHROOT="chroot \"$TARGET\""
  fi
}

#-------------------------------------------------------------------------------
##
## Cleans up the chroot environment after it is no longer needed
##
#-------------------------------------------------------------------------------
function cauldron_chroot_done() {
  local TARGET="${1:-$CAULDRON_BUILD}"

  if [[ "$CAULDRON_CHROOTINIT" -eq 1 ]]
  then
    umount "TARGET"/proc
    umount "TARGET"/dev/pts
    umount "TARGET"/dev
    unset CAULDRON_CHROOTINIT
    unset CAULDRON_CHROOT
  fi
}

#-------------------------------------------------------------------------------
##
## Scans the sorcery archspec files to find the host triplet
##
## Later, this will be used to set the value of HOST_TRIPLE in
## /etc/cauldron/config after the code to write the config file is in
## place
##
#-------------------------------------------------------------------------------
function cauldron_get_host_triple() {
  local HOST_ARCH
  local ARCH_SPEC
  local HOST_TRIPLE
  local SPEC_FILE

  # get the value for the HOST triplet from sorcery archspecs
  for spec in ${HOST_ARCH_PATH[@]}
  do
    if [[ $(find --version|grep -q 'version 4\.1\(\.\|$\)') == 1 ]]
    then
      ARCH_SPEC=$(find ${spec} -perm 400 -type f -name ${HOST_ARCH} \
        -print 2>/dev/null)
    else
      ARCH_SPEC=$(find -L ${spec} -perm 400 -type f -name ${HOST_ARCH} \
        -print 2>/dev/null)
    fi
    [[ ARCH_SPEC ]] && break
  done
  HOST_TRIPLE=$(grep "HOST=" ${ARCH_SPEC} | cut -d = -f 2)

  echo ${HOST_TRIPLE}
}

#-------------------------------------------------------------------------------
##
## Generates the base toolchain using the HOST information. This is
## done by unpacking the cache file for each spell required for the
## toolchain if it exists. If it does not exist, this may be because
## caching is disabled on the host machine, or perhaps the cache file
## was deleted by accident. Otherwise the spell must be cast within
## a chroot environment in the CAULDRON_BUILD directory.
##
#-------------------------------------------------------------------------------
function cauldron_base_toolchain() {
  local SPELL
  local VERSION
  local SPELL_CACHE
  local HOST_TRIPLE

  # exit with error if chroot not defined
  [[ -n "$CAULDRON_CHROOT" ]] || exit $ERR_CHROOT

  # set the value for HOST_TRIPLE
  HOST_TRIPLE=$(cauldron_get_host_triple)

  # grab the list of spells needed as the base tool-chain which will be
  # used to create the cross-compile tool-chain
  for SPELL in ${HOST_TOOLCHAIN}
  do
    # grab the version for the spell from sorcery's state info
    # on what's installed
    VERSION=$(grep "^${SPELL}" ${HOST_PACKAGES} | cut -d : -f 4)

    if [[ ${VERSION} ]]
    then
      # set SPELL_CACHE as shorthand for SPELL-VERSION-HOST_TRIPLE.tar.bz2
      SPELL_CACHE="${SPELL}-${VERSION}-${HOST_TRIPLE}.tar${CACHE_EXTENSION}"

      # check to see if there is already a cache file from sorcery
      # this check could be based on spell-{names,versions} reported by
      # gaze/sorcery/dispel. Mirroring code in dispel might be the best bet,
      # since that has to find the version currently installed anyway.
      if [[ -f "${HOST_SORCERY_SPOOL}/${SPELL_CACHE}" ]]
      then
        # found a cache file, copy it to the BUILD dir
        cp "${HOST_SORCERY_SPOOL}/${SPELL_CACHE}" "${CAULDRON_BUILD}"
      else
        # couldn't find a cache file, so we'll need to build one
        cauldron_build_cache_file ${SPELL}
      fi
      # unpack the cache file, effectively installing
      # the spell into the BUILD dir
      # the unpacking is done against the BUILD dir as the root dir, so
      # this should not touch the HOST filesystem at all
      tar xjf "${CAULDRON_BUILD}/${SPELL_CACHE}" -C "${CAULDRON_BUILD}"/
      [[ $? -eq 0 ]] && rm "${CAULDRON_BUILD}/${SPELL_CACHE}"
    else
      # the spell is not present on the HOST system, so it must be cast
      # inside a chroot
      cauldron_chroot_init
      ${CAULDRON_CHROOT} ${CAULDRON_CAST} ${SPELL}
      cauldron_chroot_done
    fi
  done
}

#-------------------------------------------------------------------------------
## @param spell
##
## Builds a cache file from the information provided by the install log for the
## spell passed as an argument. It expects the provided spell to include the
## version as a suffix (i.e. bash-3.2).
##
#-------------------------------------------------------------------------------
function cauldron_create_cache() {
  local SPELL=$1
  local INSTALL_LOG="${HOSTPATH}/var/log/sorcery/install/${SPELL}"
  local CACHE=${CAULDRON_CACHE}/${SPELL}.tar

  create_cache_archive ${INSTALL_LOG} ${CACHE} ${CACHE}${EXTENSION}
}

#-------------------------------------------------------------------------------
## @param spell
## @param aggressive
##
## Generates a cache file for the given spell. It will try to use information
## from an already installed/cast spell (in the case of the host system having
## sorcery configured to not generate the caches), and, failing that, will cast the
## spell and then dispel it (the second step only being performed if aggressive
## is true).
##
#-------------------------------------------------------------------------------
function cauldron_build_cache_file() {
  local SPELL=$1
  local AGGRESSIVE=$2
  local VERSION=

  # First check to see if the spell was installed, but no cache exists.
  if gaze -q installed $SPELL
  then
    # Spell is installed, generate a cache file using the install log?
    VERSION=$(grep "^${SPELL}" ${HOST_PACKAGES} | cut -d : -f 4)
    cauldron_create_cache ${SPELL}-${VERSION}
  else
    # Only do this part if the caller wants us to be aggressive in building the
    # cache.
    if $AGGRESSIVE
    then
      # Do some trickery to get a cache file. Make sure that sorcery is set to
      # generate a cache file, and if not then either set sorcery to do so or
      # build the cache file afterwards by being recursive? This should be done
      # in a build chroot so that the user's host filesystem is not polluted.
      local AGGR_BUILD="$CAULDRON_BUILD/tmp/cauldron_aggressive_cache"
      if [[ -e "$HOSTPATH/var/log/sorcery/install/${SPELL}-${VERSION}" ]]
      then
        rm -fr "$AGGR_BUILD"
        mkdir -p "$AGGR_BUILD"
        for file in "$HOSTPATH/var/log/sorcery/install/${SPELL}-${VERSION}"
        do
          cp -a --parents "$file" "$AGGR_BUILD"/
        done
        tar jcf "${SPELL}-${VERSION}.tar.bz2" \
          --transform "s#$AGGR_BUILD/##" $AGGR_BUILD/*
        [[ $? -eq 0 ]] && rm -fr "$AGGR_BUILD"
      else
        if [[ -e "$CAULDRON_BUILD/etc/sorcery/local/config" ]]
        then
          local CONFIG="$CAULDRON_BUILD/etc/sorcery/local/config"
          local ARCHIVE=$(grep "ARCHIVE=" "$CONFIG" | cut -d= -f2)
          [[ $ARCHIVE != "on" ]] &&
          sed -i 's/ARCHIVE=.*/ARCHIVE="on"/' "$CONFIG"
        fi
        cauldron_chroot_init
        "$CAULDRON_CHROOT" $CAULDRON_CAST $SPELL
        "$CAULDRON_CHROOT" $CAULDRON_DISPEL $SPELL
        cauldron_chroot_done
      fi
    fi
  fi
}

#-------------------------------------------------------------------------------
## @param stage
##
## Configures the toolchain for building on the TARGET system. In other
## words, this sets the options/variables necessary to build a
## cross-compiler system to generate binaries for the target system. The
## parameter "stage" is an int and sets the variables for stage1 and stage2 of
## the cross-compile. Stage1 is the building of the initial tools. Stage2 is for
## the building of glibc, because it's a little bit special. Stage3 is
## the cross-compilation of the basesystem via sorcery rebuild using the
## cross-compiler.
##
#-------------------------------------------------------------------------------
function cauldron_configure_toolchain() {
  local STAGE=$1

  case ${STAGE} in
    1)
      modify_config ${TARGET_LOCAL_CFG} CUSTOM_CFLAGS \
        "--host=${HOST} --target=${TARGET}"
    ;;
    2)
      modify_config ${TARGET_LOCAL_CFG} CUSTOM_CFLAGS \
        "--build=${HOST} --host=${TARGET}"
    ;;
    3)
      modify_config ${TARGET_LOCAL_CFG} CUSTOM_CFLAGS \
        "--build=${HOST} --host=${TARGET} --target=${TARGET}"
    ;;
  esac
}

#-------------------------------------------------------------------------------
## @param XXX
##
## This builds the cross-compiler to produce the TARGET binaries.
##
#-------------------------------------------------------------------------------
function cauldron_cross_toolchain() {
  # exit with error if chroot not defined
  [[ -n "$CAULDRON_CHROOT" ]] || exit $ERR_CHROOT

  # build the stage 1 tools
  cauldron_configure_toolchain 1
  cauldron_chroot_init
  ${CAULDRON_CHROOT} ${CAULDRON_CAST} binutils
  ${CAULDRON_CHROOT} ${CAULDRON_CAST} gcc
  cauldron_chroot_done

  # build glibc (stage 2)
  cauldron_configure_toolchain 2
  cauldron_chroot_init
  ${CAULDRON_CHROOT} ${CAULDRON_CAST} glibc
  cauldron_chroot_done

  # rebuild gcc (still stage 1, but this time linked against the
  # cross-glibc
  cauldron_configure_toolchain 1
  cauldron_chroot_init
  ${CAULDRON_CHROOT} ${CAULDRON_CAST} gcc
  cauldron_chroot_done

  # do a sorcery rebuild inside the BUILD dir to
  # generate the cross-compile tool-chain (stage 3)
  cauldron_configure_toolchain 3
  cauldron_chroot_init
  ${CAULDRON_CHROOT} ${CAULDRON_REBUILD}
  cauldron_chroot_done
}

#-------------------------------------------------------------------------------
## @param target_spells
##
## Performs cast on the list of spells needed for installation to the target
## system. "target_spells" is a list of spells that will be needed to install
## into the target system from the iso.
##
#-------------------------------------------------------------------------------
function cauldron_build_target_system() {
  local target_spells=$1
  local spell

  # exit with error if chroot not defined
  [[ -n "$CAULDRON_CHROOT" ]] || exit $ERR_CHROOT

  # Since we will be installing from the running ISO system instead of a giant
  # tarball, for each spell we only need to make sure that the cache file is
  # available. This will require that the ISO sorcery has caching enabled. The
  # caching should really be turned on from the very beginning though...
  cauldron_chroot_init
  [[ "$ARCHIVE" == "off" ]] && return $ERR_ARCHIVE
  for spell in $target_spells
  do
    # Cheap cop-out to get the cache generated - cast the spell to generate the
    # cache, and then dispel it from the system so that it isn't wasting space
    # on the ISO filesystem (any spells cast here should be those not required
    # for the functioning of the ISO itself, only to be installed to the target
    # system).
    ${CAULDRON_CHROOT} ${CAULDRON_CAST} $spell
    ${CAULDRON_CHROOT} ${CAULDRON_DISPEL} $spell
  done
  cauldron_chroot_done
  return $ERR_OK
}

#-------------------------------------------------------------------------------
## @param CLEANFILE
##
## Cleans out unneeded files that were used to generate the ISO, but should
## not be present on the final ISO system. CLEANFILE is a file that lists paths
## to remove (absolute paths, relative to a chroot of the iso), one file/path
## per line.
##
#-------------------------------------------------------------------------------
function cauldron_clean_iso_system() {
  local CLEANFILE=$1

  [[ -z "$CLEANFILE" ]] && return $ERR_CLEANFILE

  for i in $(sort -r $CLEANFILE)
  do
    if [[ -d $i ]]
    then
      echo "Attempting to remove directory $i..."
      rmdir $i
    else
      echo "Deleting $i"
      rm $i
    fi
  done
  return $ERR_OK
}

#-------------------------------------------------------------------------------
## @param KEEP - whether or not to keep the original .iso file in addition to
## the compressed .iso.bz2
##
## Builds the ISO filesystem using the generated ISO data and the filename
## set in the cauldron config file.
##
#-------------------------------------------------------------------------------
function cauldron_mkisofs() {
  mkisofs -R -b isolinux/isolinux.bin -c isolinux/boot.cat -no-emul-boot \
    -boot-load-size 4 -boot-info-table -o ${SMGL_ISO} ${CAULDRON_BUILD}

  if [[ "$CAULDRON_KEEPISO" == "yes" ]] ;
  then
    bzip2 -k ${SMGL_ISO}
  else
    bzip2 ${SMGL_ISO}
  fi
}

#-------------------------------------------------------------------------------
## @param INSTALLER_MODULE
##
## Adds the given installer to the ISO system. The user can then choose this
## installer either at boot-time or run-time, depending on the installer.
## INSTALLER_MODULE is currently one of shell or menu (future: X?). In theory it
## should support any installer, as long as it's packaged in its own directory and
## the name of that dir is passed as the arg. This behavior may change in the
## future though.
##
#-------------------------------------------------------------------------------
function cauldron_add_installer() {
  local MODULE=$1

  cp -r "$CAULDRON_LIBS/$MODULE" "$CAULDRON_BUILD/$ENCHANT_DATA/"
  ln -sf "$CAULDRON_BUILD/$ENCHANT_DATA/$MODULE"/bin/* \
          "$CAULDRON_BUILD"/usr/sbin/
}

#-------------------------------------------------------------------------------
##
## This creates the CAULDRON_BUILD directory, and copies sorcery and
## cauldron files into it. It also configures the CAULDRON_BUILD
## sorcery as necessary (i.e. ensures that CLEAN_SOURCE="off") for
## sanity purposes
##
#-------------------------------------------------------------------------------
function cauldron_prepare() {
  # exit with error if chroot not defined
  [[ -n "$CAULDRON_CHROOT" ]] || exit $ERR_CHROOT

  # first, ensure that the build dir exists
  mkdir -p "$CAULDRON_BUILD"

  # copy the host's resolv.conf in order to dl packages from net
  cp -L /etc/resolv.conf "$CAULDRON_BUILD"/etc/resolv.conf

  cauldron_sorcery_install "$CAULDRON_BUILD"
  mkdir -p "$CAULDRON_BUILD"/var/spool/sorcery
  cp -f "$HOSTPATH"/var/spool/sorcery/sorcery-${SORCERY_BRANCH}.tar${EXTENSION}

  # cauldron is a spell
  # there is a spoon
  cauldron_chroot_init
  "$CAULDRON_CHROOT" "$CAULDRON_CAST" cauldron
  cauldron_chroot_done
}

#-------------------------------------------------------------------------------
## @param sorcery_branch
## @param download_path
##
## Downloads a fresh sorcery source tarball from the net, and places it in
## download_path.
##
#-------------------------------------------------------------------------------
function cauldron_download_sorcery() {
  local BRANCH=$1
  local SPOOL=$2
  local SORCERY="sorcery-$BRANCH.tar.bz2"

  # run in a subshell as an easy way of not messing with the working directory
  (
    cd ${SPOOL}
    wget http://download.sourcemage.org/sorcery/$SORCERY
  )
}

#-------------------------------------------------------------------------------
## @param force_download
##
## Installs sorcery into the ISO system. If force_download is "yes", it will
## download a fresh copy from the net. Otherwise, it will check to see if the
## sorcery sources are present in the host system, and copy those first, but if
## they cannot be found it will resort to downloading them. It shouldn't matter
## if the version of sorcery is a little old, since a system update can be
## performed inside $CAULDRON_BUILD after the base toolchain is set up. The
## branch should be one of {stable, test, devel}, and is set in the cauldron
## config file.
##
#-------------------------------------------------------------------------------
function cauldron_sorcery_install() {
  local force_download=$1
  local BRANCH="$ISO_SORCERY_BRANCH"
  local SPOOL="$CAULDRON_BUILD/var/spool/sorcery"

  # first, check to see if we will copy or download the sorcery source tarball
  # and get the source tarball and place it in CAULDRON_BUILD
  if [[ -e "$HOST_SORCERY_SPOOL"/sorcery-${BRANCH}.tar.bz2 ]]
  then
    if [[ "$force_download" == "yes" ]]
    then
      cauldron_download_sorcery $BRANCH "$SPOOL"
    else
      cp "$HOST_SORCERY_SPOOL"/sorcery-${BRANCH}.tar.bz2 "$SPOOL"
    fi
  else
    cauldron_download_sorcery ${BRANCH} "$SPOOL"
  fi

  # unpack the source tarball
  tar -C "$CAULDRON_BUILD"/usr/src -jxf "$SPOOL"/sorcery-${BRANCH}.tar.bz2

  # install the source tarball, relative to CAULDRON_BUILD
  "$CAULDRON_BUILD"/usr/src/sorcery/install "$CAULDRON_BUILD"
}

#-------------------------------------------------------------------------------
##
## Cleans up the tmp directories and such forth
##
#-------------------------------------------------------------------------------
function cauldron_cleanup() {
  [[ ${CAULDRON_CLEAN} == "yes" ]] && rm -fr "$CAULDRON_BUILD"
  rm -fr "$CAULDRON_TMP"
}

#-------------------------------------------------------------------------------
##
## This software is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation; either version 2 of the License, or
## (at your option) any later version.
##
## This software is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this software; if not, write to the Free Software
## Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
##
#-------------------------------------------------------------------------------

# vim:ai:tw=80:tabstop=2:softtabstop=2:shiftwidth=2:expandtab
