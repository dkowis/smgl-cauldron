#!/bin/bash

#uses files:
# /var/installer/data/optionalSpellList
# Expected format (one spell per line):
# "spell" "version" "off" "short description with \" quoted"
# /tmp/prunedOptionalList

# optional spell stuff
function optional_screen() {

  need_dependency disk          &&
  need_dependency install_start &&
  need_dependency linux         &&
  need_dependency bootloader    &&
  need_dependency network       ||
  {
    echo "Declining to do final configuration due to missing dependencies..."
    return 1
  }

  if ! check_dependency dev_format ||
    confirm "Do you want to reconfigure /dev?" --defaultno ;then
    opt_choose_dev
  fi

  #prune the optional list
  opt_prune_list

  #display the pruned list
  # TODO: add spell's version as description and description as item help
  local SPELLS=$( eval "run_dialog --single-quoted --item-help \
    --title 'Optional Spells' --checklist 'Select optional spells to install' \
    0 0 0 $(cat /tmp/prunedOptionalList)" )

  #queue up the spells to install
  si_queue $SPELLS

  #ask about installing the caches
  if ! check_dependency install_caches && # Don't ask again
     confirm "Install extra cache files? Makes it easier to install a program you forgot
without having to get out the ISO again. (recommended)" ;then
    si_queue Iso.Caches
  fi
  rm -f /tmp/prunedOptionalList

}

#prunes the list of optional spells
# removing those that are already installed
function opt_prune_list() {
  local LINE
  rm -f /tmp/prunedOptionalList

  while read LINE ;do #SUBSHELL!
    local SPELL=$( echo ${LINE} | cut -d'"' -f 2 )
    if si_query ${SPELL} ;then
      echo "${LINE}"
    fi
  done < ${STATE_DIR}/optionalSpellList | sort | #let's make this one long line,
  tr $'\n' ' ' > /tmp/prunedOptionalList # eval doesn't like line breaks
}

function opt_choose_dev() {
  local DEVSYST
  local DEVROOT
  DEVSYST=$( run_dialog --single-quoted --title 'choose /dev system'  \
    --item-help                                                       \
    --menu "Select the system you want to manage your /dev directory" \
    0 0 0 \
    "udev" "udev dynamically creates device nodes in userspace"       \
      "udev has a daemon to create nodes in /dev as the devices get recognized" \
    "static" "static device nodes in the filesystem tree"             \
      "does not require any daemons, but has every device known to linux in /dev" ) &&
#    "devfs" "dynamic device nodes in a virtual file system"           \
#      "devfs is a mountable kernel space file system used in the 2.4 kernel" )    &&
  if umount $TARGET/dev 2>/dev/null ;then
    DEVROOT=$TARGET/dev
  else
    mount --bind $TARGET /mnt/mnt
    DEVROOT=/mnt/mnt/dev
  fi &&
  case $DEVSYST in
    # WORKAROUND: For some reason, it seems we can't unmount $TARGET/dev.
      "udev")
             si_queue udev
             pushd $DEVROOT >/dev/null
             /sbin/MAKEDEV std console fd
             mknod initctl p
             popd >/dev/null
             fill_dependency dev_format udev
           ;;
    "static")
             cp /sbin/MAKEDEV $DEVROOT/MAKEDEV
             pushd $DEVROOT >/dev/null
             ./MAKEDEV generic-nopty md
             mknod initctl p
             popd >/dev/null
             fill_dependency dev_format static
           ;;
#     "devfs")
#             si_queue devfsd
#             fill_dependency dev_format devfs
#           ;;
  esac
  [[ $DEVROOT == /mnt/mnt/dev ]] && umount /mnt/mnt
  sed -i "s/^DEVICES=.*$/DEVICES=$DEVSYST/" ${FINALFILES}/etc/sysconfig/devices
}
