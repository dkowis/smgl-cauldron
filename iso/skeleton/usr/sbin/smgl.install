#!/bin/sh
########################################################################
########################################################################
########################################################################
############ BIG ASS NOTE!!! ###########################################
########################################################################
# I, David Kowis, am doing lots o work on this file, i've split it and #
# a bunch of other stuff, it would probably be unwise to make changes  #
# in this file, because I'm reworking it.                              #
# Questions? email me at dkowis@shlrm.org                              #
########################################################################
########################################################################
########################################################################
########################################################################

########################################################################
# Copyright 2004 by Hamish Greig <hgreig@bigpond.net.au>               #
# Copyright 2004 by Kevin Dahan <unet@sourcemage.org>                  #
# Copyright 2003 by Laurent Wandrebeck <low@sourcemage.org>            #
# Copyright 2003 by Benoit Papillault <benoit.papillault@free.fr>      #
# Copyright 2003 by Seth Woolley <seth@tautology.org>                  #
# Copyright 2002 by Source Magers                                      #
# Copyright 2001 by Kyle Sallee                                        #
########################################################################
#                                                                      #
# This program is free software; you can redistribute it and/or modify #
# it under the terms of the GNU General Public License as published by #
# the Free Software Foundation; either version 2 of the License, or    #
# (at your option) any later version.                                  #
#                                                                      #
#   This program is distributed in the hope that it will be useful,    #
#   but WITHOUT ANY WARRANTY; without even the implied warranty of     #
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      #
#   GNU General Public License for more details.                       #
#                                                                      #
#  You should have received a copy of the GNU General Public License   #
#  along with this program; if not, write to the Free Software         #
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston,               #
#  MA  02111-1307  USA                                                 #
#                                                                      #
########################################################################
#         This is a menu driven process of                             #
#  installing from the Source Mage GNU/Linux ISO                       #
#                                                                      #
#  It currently relies on some files in /etc/installerdata/*, the      #
#  files are available in the same place you got this script. If not,  #
#  then contact the supplier of this script.                           #
#                                                                      #
#  1) /etc/installerdata/install.guide                                 #
#         a text file describing the installation process and          #
#         explaining the options available.                            #
#  2) /etc/installerdata/install-list                                  #
#         a list of the minimum required spells to be able to start    #
#         casting or a rebuild.                                        #
#  3) /etc/installerdata/optional-list                                 #
#         a list of useful spells that are optionally offered for      #
#         install.                                                     #
#  4) /etc/installerdata/kernel.help                                   #
#         a help file suggesting options needed by the SMGL system     #
#  5) /etc/installerdata/raidlevel                                     #
#         a text file listing the raid levels and simple explanations  #
#         of them.                                                     #
#  6) /etc/installerdata/fstab                                         #
#         a listing of virtual filesystems for the installer to add    #
#         the physical systems entries to.                             #
#  7) /etc/installerdata/version                                       #
#     contains a line with VERSION=20040414                            #
#                                                                      #
########################################################################

# Documentation of variables used in several functions
#
# DEBUG="yes"/"no". If set to "yes", some debug message will be displayed
# BOOTLOADER="grub"/"lilo"/"yaboot". 
# MBR="yes"/"no". If set to "yes", the bootloader is installed in the MBR
#         otherwise, the bootloader in the /boot partition. This variable is
#         not define on ppc machines.
# KERNEL="copy"/"compile". If set to "copy", the kernel is copied on the target
#         otherwise, the kernel is compiled from sources.
# DEVICES="udev"/"static". If set to "udev", the target system will use a udev
#         generated /dev. Otherwise, it will use a /dev generated by MAKEDEV.
# FS_PROGS=( "e2fsprogs" "reiserfsprogs" "xfsprogs" "jfsutils" ). Contains a
#         shell array of spell needed to provide fsck command line for all
#         used filesystems in the new system.
# ROOT=/dev/hda1. This is the device used to mount the root filesystem.
# BOOT=/dev/hda2. If defined, this is the device used to mount /boot.
# DONE_INSTALLED="yes". If defined, this variable indicates that the target
#         system is properly installed with its kernel. It is set at the end
#         of 'install_to_target'

# Bootloader notes:
# for each bootloader, we need three shell functions:
#
# bootloader_$BOOTLOADER_conf
#   this function creates a default working configuration file for the
#   bootloader (using either precompiled or compiled kernel) and does not
#   install it
#
#   bootloader | file to edit        | command to run (first install)
#   grub       | /boot/grub/menu.lst | none           (grub-install)
#   lilo       | /etc/lilo.conf      | lilo           (lilo)
#   yaboot     | /etc/yaboot.conf    | ybin           (yabootconfig)
#
# bootloader_$BOOTLOADER_edit
#   this function allows the user to edit the current configuration file and
#   does NOT install it.
#
# bootloader_$BOOTLOADER_install
#   this function install the bootloader with the current configuration file.
#   it requires a proper configuration file.
#

#introduction: don't remember ever seeing this do anything...
# SECTION: MISC
introduction()  {

  local MSG="The purpose of Source Mage GNU/Linux is to return
control to System Administrators that the wizards and
maintainers of modern distributions have steadily
chipped away."

  "${DIALOG[@]}" --title "Welcome to Source Mage GNU/Linux" \
    --msgbox "${MSG}" 9 60

  local MSG="Source Mage GNU/Linux empowers System Administrators
to choose:

  the architecture that programs are compiled for, the
  dependencies a program is compiled with, compiler
  optimizations, and compile time options.

And it provides the conveniences of:

  command line and menu driven package management,
  ASCII configuration and data files, FHS 2.2
  compliant filesystem hierarchy, parallel simpleinit
  and networking."

  "${DIALOG[@]}"  --cr-wrap                             \
	  --title  "The Benefits of Source Mage GNU/Linux"  \
	  --msgbox "${MSG}" 18 60

}

# press_enter: display a single line and wait for the user to press enter
# SECTION: MISC
press_enter() {

  read -p "Press enter..."

}

#inputbox: creates a simple input box based off the two passed parameters
# SECTION: MISC
inputbox()  {

  "${DIALOG[@]}"  --nocancel --inputbox "$1" 8 60 "$2"

}

#chroot_cmd: Creates a chrooted environment
# usage: chroot_cmd cmd args...
# SECTION: MISC
chroot_cmd() {

  mount --bind /dev  "${TARGET}/dev"
  mount --bind /proc "${TARGET}/proc"
  mount --bind /var/cache/sorcery "${TARGET}/var/cache/sorcery"

  if [ -z $SWAPON ]; then chroot "${TARGET}" swapon -a ; fi

  chroot "${TARGET}" "$@"

  if [ -z $SWAPON ]; then chroot "${TARGET}" swapoff -a ; fi

  umount "${TARGET}/dev"
  umount "${TARGET}/proc"
  umount "${TARGET}/var/cache/sorcery"

  echo "Runnning chroot "${TARGET}" "$@"" >> /tmp/installer-debug

}

#confirm: displays a confirm dialog
# SECTION: MISC
confirm()  {

  if  [  -z  "$CONFIRM"  ];  then

    if  [  -n  "$2"  ];  then  false
                         else  true
    fi

  else

# yes, we use $2 instead of "$2", since it is an
# optional argument (first) and it may contain several
# words (second)

    "${DIALOG[@]}" $2 --yesno  "$1" 6 60
  fi

}

#goodbye: the finishing function. Copy the debug log if theres a certain
# file in the /tmp dir. then ask to reboot.
# SECTION: ???
goodbye() {

    # copy the install-debug log 
    if [ -d ${TARGET}/var/log ] && [ -s /tmp/installer-debug ]
    	then cp -f /tmp/installer-debug ${TARGET}/var/log/SMGL-$VERSION-install.log
    fi

    PROMPT="Reboot now?" 
    if  confirm  "${PROMPT}" --defaultno;  then
        exec shutdown -r -q now
    else
        exit  0
    fi
}

#list_discs: used when running cfdisk
#  should be placed with that section...
# SECTION: DISK_STRUCTURE
list_discs()  {

  # sfdisk reads /proc/partitions for discs so it is the same as cat
  # /proc/partitions but better output

  # however, sfdisk -s outputs an error messages on ppc about
  # unrecognized msdos partitions. we ignore it with 2>/dev/null

  sfdisk -s 2>/dev/null | grep '^/dev' | cut -d : -f1 | \
	while read DISK;
	do
  # a cdrom has no geometry allowing us to remove it from the list
	  if ! sfdisk -qg "${DISK}" | grep -q "cannot get geometry"; then
		SIZE=`sfdisk -sq "${DISK}"`
		echo  "${DISK}"
		echo  "Size ${SIZE}"
     fi
  done

}

#list_parts:  creates a list of partitions used when mounting
#   should be placed with that section.
# SECTION: DISK_STRUCTURE
list_parts()  {
  # grepping a non-existant file gives an error
  touch /etc/raidtab
  for PARTITION in `cat /proc/partitions |awk '$3 !~ /^1$/ {print $4}' | grep -v ram | grep -v disc | grep -v name |sed -e 's/ //g'`;
  do if ! sfdisk -s | grep -q /dev/$PARTITION\: && !  echo  $FS_LIST | grep -q $PARTITION\  && ! `grep device /etc/raidtab | grep -q $PARTITION\ `
         then echo  "/dev/${PARTITION}"
           if [[ `uname -r` == 2.6.* ]];  then
			   if [[ $PARTITION == md* ]]; then
				   
				   echo  "Size `sfdisk -sq /dev/$PARTITION` Type RAID array" \
					   || echo "size and type unknown"
			   else
				   echo  "Size `sfdisk -sq /dev/$PARTITION` Type `sfdisk -lq | grep $PARTITION\ | awk '{print $(NF-1) " " $NF}' | sed -e s/[0123456789].[\ ]//g` " || echo "size and type unknown"
                fi

            # 2.4.25 wrongly tries to list removable media (cdroms,
            # etc) which have no geometry so to avoid a lot of errors,
            # I modified the check, but some weird mojo wouldn't let
            # the "backticks within backticks" work so I used both ` `
            # and $()

           else if [[ $PARTITION == md* ]]
                then echo  "Size `sfdisk -sq /dev/$PARTITION` Type RAID array " || echo "size and type unknown"
                else echo  "Size `sfdisk -sq /dev/$PARTITION` Type `sfdisk -lq $(echo /dev/$PARTITION | sed -e s/part[0123456789]*/disc/) | grep $PARTITION\  | awk '{print $(NF-1) " " $NF}' | sed -e s/[0123456789].[\ ]//g` " || echo "size and type unknown"
                fi
           fi
     fi
  done

}

# TODO: find the difference between this function and the function above
# TODO: determine if they can be combined or something, they're very similar
# the raid functions use of --checklist means the regular list_parts
# wouldn't work.
# SECTION: DISK_STRUCTURE
list_raid_parts()  {
  # grepping a non-existant file gives an error
  touch /etc/raidtab
  for PARTITION in `cat /proc/partitions |awk '$3 !~ /^1$/ {print $4}' | grep -v ram | grep -v disc | sort | grep -v name | sed -e 's/ //g'`;
  do
    if ! `sfdisk -s | grep -q /dev/$PARTITION\:` && ! echo $FS_LIST | grep -q $PARTITION\  && ! `grep device /etc/raidtab | grep -q $PARTITION\ `
    then echo  /dev/$PARTITION
         if [[ `uname -r` == 2.6.* ]] 
         then if [[ $PARTITION == md* ]]
              then echo  "Size `sfdisk -sq /dev/$PARTITION` Type RAID array " || echo "size and type unknown"
              else echo  "Size `sfdisk -sq /dev/$PARTITION` Type `sfdisk -lq | grep $PARTITION\  | awk '{print $(NF-1) " " $NF}' | sed -e s/[0123456789].[\ ]//g` " || echo "size and type unknown"
              fi

           # 2.4.25 wrongly tries to list removable media (cdroms,
           # etc) which have no geometry so to avoid a lot of errors,
           # I modified the check, but some weird mojo wouldn't let
           # the "backticks within backticks" work so I used both ` `
           # and $()

         else if [[ $PARTITION == md* ]]
              then echo  "Size `sfdisk -sq /dev/$PARTITION` Type RAID array " || echo "size and type unknown"
              else echo  "Size `sfdisk -sq /dev/$PARTITION` Type `sfdisk -lq $(echo /dev/$PARTITION | sed -e s/part[0123456789]*/disc/) | grep $PARTITION\  | awk '{print $(NF-1) " " $NF}' | sed -e s/[0123456789].[\ ]//g` " || echo "size and type unknown"
              fi
         fi
         echo  off
    fi
  done

}

#get_part: display the dialog menu for selecting a partition
# should go with the filesystem part
# SECTION: DISK_STRUCTURE
get_part()  {

  TITLE="Partition Selection Menu"

  HELP="Please select a partition. Sizes are in blocks"

  IFS=$'\n' LIST_PARTS=( `list_parts` )

  if [ "${DEBUG}" = "yes" ]; then
    for PART in "${LIST_PARTS[@]}";
    do
      echo "PART=${PART}" >&2
    done
    read -p "press enter..."
  fi

  "${DIALOG[@]}" \
	  --title     "$TITLE"  \
	  --menu      "$HELP"   \
	  7 60 0                \
	  "${LIST_PARTS[@]}"

}

#choose_raid_parts: Displays the RAID menu
#SECTION: DISK_STRUCTURE
choose_raid_parts()  {
  TITLE="Installer menu for RAID device generation"
   HELP="Please select partitions to make the RAID array. \
Sizes are in blocks\n\
Use cancel or esc to leave this menu\n\
Lilo and grub can only boot from a RAID 1 array, \n\
You can return to the previous menu and repartition so you have a separate /boot partition."

  IFS=$'\n' LIST_RAID_PARTS=( `list_raid_parts` )

  "${DIALOG[@]}" \
	  --title     "$TITLE"     \
	  --separate-output        \
	  --checklist "$HELP"      \
	  0 60 0                   \
	  "${LIST_RAID_PARTS[@]}"

}

# choose_raid_level: menu for selection of raid level
# SECTION: DISK_STRUCTURE
choose_raid_level()  {

  TITLE="RAID level selection Menu"

  HELP="Please select RAID level. For more detailed
descriptions of RAID levels read the Source Mage
GNU/Linux Install Guide. Use <Cancel> or Esc to leave
this menu"

#TODO: fix usage of the IFS?
  IFS=$'\n' LIST_RAID_LEVEL=( `cat /etc/installerdata/raidlevel` )

  "${DIALOG[@]}" \
	  --title     "$TITLE"     \
	  --item-help              \
	  --menu      "$HELP"      \
	  10 60 0                   \
	  "${LIST_RAID_LEVEL[@]}"

}

#get_disk: display's menu to select a disk
#SECTION: DISK_STRUCTURE
get_disc()  {

  TITLE="Disk Selection Menu"

  HELP="Please select a disk. Sizes are listed in blocks."

  IFS=$'\n' LIST_DISCS=( `list_discs` )

  if [ "${DEBUG}" = "yes" ]; then
	for DISC in "${LIST_DISCS[@]}";
	do
	  echo "DISC=${DISC}" >&2
    done
	read -p "press enter..."
  fi

  "${DIALOG[@]}" \
	  --title     "$TITLE"  \
	  --menu      "$HELP"   \
	  7 60 0                \
	  "${LIST_DISCS[@]}"

}

#get_filesystem: displays the menu to select a filesystem
# SECTION: DISK_STRUCTURE
get_filesystem()  {

   TITLE="Filesystem Selection Menu"
    HELP="Please select a filesystem"
    EXT2="Second Extended file system "
    EXT3="Second Extended journaling file system "
     XFS="XFS journaling file system "
  REISER="Reiserfs journaling file system "
     JFS="JFS journaling file system "
    SWAP="Swap Partition"

  "${DIALOG[@]}"  --title     "$TITLE"   \
           --menu      "$HELP"    \
           7 60 0                 \
           "ext2"      "$EXT2"    \
           "ext3"      "$EXT3"    \
           "reiserfs"  "$REISER"  \
           "swap"      "$SWAP"    \
           "xfs"       "$XFS"	  \
           "jfs"       "$JFS"

}

#show_keymaps: Does something with keymaps, perhaps just displays them
# TODO: Figure out where this is used
# SECTION: LOCALE_CONFIG
show_keymaps()  {

  KEYDIR="/usr/share/keymaps/i386"

  azerty="`ls  $KEYDIR/azerty`"
  dvorak="`ls  $KEYDIR/dvorak`"
  fgGIod="`ls  $KEYDIR/fgGIod`"
  qwerty="`ls  $KEYDIR/qwerty`"
  qwertz="`ls  $KEYDIR/qwertz`"

  MAP_FILES=`echo  -e  "$azerty\n$dvorak\n$fgGIod\n$qwerty\n$qwertz"  |
             sort  |  sed  "s/\.kmap\.gz//"`

  for  MAP  in  $MAP_FILES;  do
    echo  "${MAP}"
    echo  "keymap "
  done

}

#keymap_menu: display's the menu for a keymap selection
# SECTION: LOCALE_CONFIG
keymap_menu()  {

     TITLE="Keymap Selection Menu"
      HELP="Please select your preferred keymapping."

  IFS=$'\n' KEYMAPS=( `show_keymaps` )
 
  KEYMAP=`"${DIALOG[@]}" \
	  --title  "$TITLE"  \
	  --menu   "$HELP"   \
	  7 60 0             \
	  "${KEYMAPS[@]}"` &&
  
  LOADKEYS="loadkeys  $KEYMAP"          &&

  loadkeys  $KEYMAP

  echo -e "Running $LOADKEYS" >> /tmp/installer-debug
}

#fdisc : displays the menu for running a partition manager
# STRUCTURE: DISK_STRUCTURE
fdisc()  {

  if [ "$ARCH" = "ppc" ]; then
	DISC=`get_disc`                                             &&
	PROMPT="Remember you need to create a bootstrap partition \
        first (type 'b' at the prompt). " &&
	if  confirm  "${PROMPT}";  then
	  mac-fdisk  $DISC
	  echo "Running mac-fdisk on $DISC" >> /tmp/installer-debug
	fi
  else
	CFDISK="Curses based disk partition table manipulator"  
	FDISK="Partition table manipulator"
	PARTED="Create, destroy, resize, and copy partitions"

	HELP="Please create at least a root partition. A boot
partition is recommended, for RAID and some filesystems
it is mandatory. Lilo can only boot from a RAID 1 array
and xfs or reiserfs formatting can cause problems with
the MBR. Grub can boot from any filesystem, but still
can't boot from RAID unless it is RAID 1 or has a
separate boot partition"

	TITLE="Partitioning Menu"
	# cheat again -> '
	DISC=`get_disc`                                             &&
	PROG=`"${DIALOG[@]}" --title   "$TITLE" \
		--menu    "$HELP" \
		13 60 0 \
		"cfdisk"  "$CFDISK" \
		"fdisk"   "$FDISK" \
		"parted"  "$PARTED" ` &&
	
	PROMPT="Are you certain that you want to run ${PROG} on ${DISC}" &&

    if confirm "${PROMPT}"; then
	  echo "Running $PROG on $DISC" >> /tmp/installer-debug
      if ! "${PROG}" "${DISC}"; then
	    read -p "press enter..."
      fi
    fi
  fi

}

#
# TODO: REAL DOCUMENTATION OMFG!!!!!1
# usage : get_mk_prog ext3
# output: program name to make the specified filesystem
# function to provide correct name for the filesystem-formatting
# binary (eg. mk??fs)

get_mk_prog()  {

  case  $1  in
    reiserfs)  echo  "mkreiserfs"  ;;
        swap)  echo  "mkswap"      ;;
        ext2)  echo  "mkfs"        ;;
        ext3)  echo  "mkfs"        ;;
         xfs)  echo  "mkfs"        ;;
         jfs)  echo  "mkfs"        ;;
  esac

}

#check_partition: displays the screen that asks whether to check for errors
# SECTION: DISK_STRUCTURE
check_partition()  {

  PROMPT="Check for errors?"

  case  $1  in  
    ext2|ext3|jfs|swap)  if   confirm  "${PROMPT}" --defaultno;  then
                       echo  "-c";  
                     fi    ;;
                 *)  true  ;;
  esac

}

# filesystems using mkfs need switches passed
# SECTION: DISK_STRUCTURE
get_fstype()  {

  case  $1  in
    ext2)  echo  "-text2"  ;;
    ext3)  echo  "-text2"  ;;
     xfs)  echo  "-txfs"   ;;
     jfs)  echo  "-tjfs"   ;;
       *)  true            ;;
  esac

}


#TODO: Meaningful function names!
#use_the_force: something about forcing ?
# SECTION: DISK_STRUCTURE
use_the_force()  {

  case  $1  in
    ext3)  echo  "-j"  ;;
     xfs)  echo  "-f"  ;;
       *)  true        ;;
  esac

}

# mk_swap_file: displays the menu for creating a swapfile
# SECTION: DISK_STRUCTURE
mk_swap_file()  {

  LOCATION_PROMPT="Please enter the location for the swapfile."
      SIZE_PROMPT="Source Mage GNU/Linux recommends 1GB of RAM + SWAP. \n\
      Please enter the number of megabytes to use for this swapfile."
          SUCCESS="Swapfile created."
          FAILURE="Problem creating swapfile."
             ZERO="/dev/zero"

    DEVICE=`inputbox  "$LOCATION_PROMPT"  "/.swapfile"`    &&
  SWAPFILE="$TARGET$DEVICE"                               &&
      SIZE=`inputbox  "$SIZE_PROMPT"      "1024"`         &&
    PROMPT="Make swapfile $SWAPFILE of $SIZE megabytes?"  &&

  if  confirm  "${PROMPT}"; then
    if  dd  of=$SWAPFILE  if=$ZERO bs=1M count=$SIZE  &&
           mkswap      $SWAPFILE                         &&
           chmod  000  $SWAPFILE; then
      DP="$DEVICE	none"
	  FOL="swap	defaults	0 0"
	  FSTAB_ENTRY="$DP	$FOL"
	  FS_LIST=`echo  -e  "$FSTAB_ENTRY\n$FS_LIST"`
	  "${DIALOG[@]}"  --msgbox  "$SUCCESS" 6 60
	else
	  press_enter
	  "${DIALOG[@]}"  --msgbox  "$FAILURE" 6 60
	  return 1
    fi
  fi
}

#make_fsys: displays the menu for filesystem creation
# SECTION: DISK_STRUCTURE
make_fsys()  {

  SUCCESS="Filesystem created"
  FAILURE="Filesystem creation failed"
  
     PROG=`get_mk_prog  $FSYS`

  COMMAND="Would you like to initialize ${DEVICE} using the
following command (if you answer NO, then ${DEVICE}
will just be mounted asis, unformatted): $PROG $FSTYPE
$CHECK $FORCE $DEVICE"

  if  "${DIALOG[@]}" --yesno  "${COMMAND}" 8 60; then
    if  $PROG $FSTYPE $CHECK $FORCE $DEVICE; then
      "${DIALOG[@]}"  --msgbox  "$SUCCESS" 6 60
    else
	  press_enter
      "${DIALOG[@]}"  --msgbox  "$FAILURE" 6 60
      return 1
    fi

    echo -e "$DEVICE formatted as $FSYS with $PROG $FSTYPE $CHECK $FORCE $DEVICE and mounted" >> /tmp/installer-debug
  fi

}

#mount_fsys: displays the menu for mounting a filesystem
# SECTION: DISK_STRUCTURE
mount_fsys()  {

    MOUNT=$TARGET$MNT_POINT
  SUCCESS="Mounted $DEVICE on $MOUNT"
  FAILURE="Failed mounting $DEVICE on $MOUNT"

  case  $FSYS  in
    ext2|ext3|reiserfs|xfs|jfs)
      if  mkdir -p $MOUNT && mount -t $FSYS -o $OPTIONS $DEVICE $MOUNT
      then
        case  $MNT_POINT  in
              /)  ROOT="${DEVICE}"  ;;
          /boot)  BOOT="${DEVICE}"  ;;
        esac
        "${DIALOG[@]}"  --msgbox  "$SUCCESS" 6 60
      else
		press_enter
        "${DIALOG[@]}"  --msgbox  "$FAILURE" 6 60
        return 1
      fi
    ;;
    swap)

      PROMPT="Mount swap partition (or swapfile) now so it is usable
             during install ? (Recommended)"

      if confirm "${PROMPT}"; then
        swapon "${PART}" && export SWAPON=on
	  fi
	  ;;
  esac

}


# make_fstab_line: not sure
# SECTION: DISK_STRUCTURE
make_fstab_line()  {

         DP="$DEVICE	$MNT_POINT"    &&
        FOL="$FSYS	$OPTIONS"  &&
FSTAB_ENTRY="$DP	$FOL	$LAST"     &&
    FS_LIST=`echo  -e  "$FS_LIST\n$FSTAB_ENTRY"`

}


# determine_fstab_settings: what settings to write to fstab for each filesystem
# SECTION: DISK_STRUCTURE
determine_fstab_settings()  {

  LAST="0 2"
  case  $FSYS  in
        swap)  OPTIONS="defaults"                 ;;
    reiserfs)  OPTIONS="defaults,notail,noatime"  ;;
        ext3)  OPTIONS="defaults,noatime"         ;;
         xfs)  OPTIONS="defaults,noatime"         ;;
         jfs)  OPTIONS="defaults,noatime"         ;;
        ext2)  OPTIONS="defaults,noatime"         ;;
  esac
  case $MNT_POINT in
    /)  LAST="0 1"  ;;
    *)  LAST="0 2"  ;;
  esac

}

#get_mount_point: displays the menu for mounting filesystems other than root
# allows people to enter a mount point for other things
# SECTION: DISK_STRUCTURE
get_mount_point()  {

  PROMPT="Please enter a mount point"

  if    [  -z  "$ROOT"  ];  then

    MNT_POINT="/"
    [  "$FSYS"  !=  "swap"  ]

  elif  [  "$FSYS"  ==  "swap"  ];  then

    MNT_POINT="none"

  else

    MNT_POINT=`inputbox  "$PROMPT"  "/"`  &&
    [  -n  "$MNT_POINT"  ]                &&
    [  "$MNT_POINT"  !=  "/"  ]  

  fi

}


#mount_partition: what things to do to mount a partition
#SECTION: DISK_STRUCTURE
mount_partition()  {

      PART=`get_part`                  &&
      FSYS=`get_filesystem`            &&
     CHECK=`check_partition  $FSYS`    &&
     FORCE=`use_the_force    $FSYS`    &&
    FSTYPE=`get_fstype       $FSYS`    &&
    DEVICE=$PART                       &&

  get_mount_point                      &&
  determine_fstab_settings             &&
  make_fsys                            &&
  mount_fsys                           &&
  make_fstab_line                      
  
}

#mounty: confirms completion of making partions
# TODO: meaningful function names!
# SECTION: DISK_STRUCTURE
mounty()  {

      PROMPT="Are you done making partitions?"
  ROOT_FIRST="The root partition must be mounted first"

  if    [  -n  "$ROOT"  ];   then
    mount_partition
  elif  confirm  "${PROMPT}";  then
    "${DIALOG[@]}"  --msgbox  "$ROOT_FIRST"  6 60
    mount_partition
  fi

}

#mk_raid_device: another function for raid stuff
# SECTION: DISK_STRUCTURE
# TODO: determine what this does...
mk_raid_device() {
   mk_raid_config 
   PROMPT="Edit the raidtab before initialising the arrays ?\nExperienced users might like to change RAID 5 parity-algorithm options \
or even change a disk to be spare within the array"
 if [ -s /etc/raidtab ]; then
   if confirm "${PROMPT}" --defaultno; then
     $EDITOR /etc/raidtab
   fi
 fi                                        
   PROMPT="Make and start the RAID arrays now ?\nCancel or Esc returns to install menu without changing \
the partition tables and initialising array"
 if [ -s /etc/raidtab ] ; then 
   if confirm "${PROMPT}" --defaultno; then
   # read which partitions are to be in the array
   RD_PARTS="`grep device /etc/raidtab |awk '{print $2}'`" 

   # this ugly thing finds which discs the partitions belong to, and
   # converts the partition type to raid auto-detect

   # tr is used as our IFS runs space separated vars together

   if [[ `uname -r` == 2.4.* ]]
   then RD_DISC="`echo $RD_PARTS | sed s/part[0123456789]*/disc/g | tr ' ' '\n' | sort | uniq`"  
   else RD_DISC="`echo $RD_PARTS | sed s/[0123456789]*//g | tr ' ' '\n' | sort | uniq`"
   fi
   for ind_disk in `echo $RD_DISC | tr ' ' '\n'`
   do if [[ `uname -r` == 2.6.* ]]; 
      then sfdisk -d  $ind_disk > /tmp/`echo $ind_disk | sed 's:/dev/::'`.table
           for part in `echo $RD_PARTS | tr ' ' '\n'`
           do if grep -q $part /tmp/`echo $ind_disk | sed 's:/dev/::'`.table
              then sed -i -e "/`echo $part | tr '/' ' ' | awk '{print $NF}'`/s:Id=..:Id=fd:g" /tmp/`echo $ind_disk | sed 's:/dev/::'`.table
              fi
           done
		   sfdisk -f -q $ind_disk < /tmp/`echo $ind_disk | sed 's:/dev/::'`.table
       else sfdisk -d  $ind_disk > /tmp/disk.table
           for part in `echo $RD_PARTS | tr ' ' '\n'`
           do if grep -q $part /tmp/disk.table
              then sed -i -e "/`echo $part | tr '/' ' ' | awk '{print $NF}'`/s:Id=..:Id=fd:g" /tmp/disk.table
              fi
           done
		   sfdisk -f -q $ind_disk < /tmp/disk.table
      fi
   done

   # now make the arrays and start them
   for RDEV in `grep raiddev /etc/raidtab | awk '{print $2}'`;
   do
     mkraid -R $RDEV
	 echo "making and initialising $RDEV" >> /tmp/installer-debug
   done
   else return 1
   fi
 fi

}

# mk_raid_config: don't know what...
# TODO: determine what this does
# SECTION: DISK_STRUCTURE
mk_raid_config() {

#detect an already initialised array and set the counter
if [ -z $PLACE ]
then if grep -q md /proc/partitions
     then for i in `cat /proc/partitions | grep md | awk '{print $4}'| sort`; 
          do if  [ -h /dev/$i ]; 
             then PLACE=`echo $i | cut -c 3`
             else PLACE=`echo $i | cut -d/ -f2`
             fi 
          done
     else PLACE=-1
     fi
fi
((PLACE++))
# choose which partitions to turn into an array
RAID_PARTS=`choose_raid_parts`                   &&
# tr is used as our IFS runs space separated vars together
echo $RAID_PARTS | tr ' ' '\n' > /tmp/raid.parts &&
NR_DISCS=`cat /tmp/raid.parts | wc -l`           &&
# choose raid-level
RAIDLEVEL=`choose_raid_level`                    &&
#write the raidtab
echo "raiddev /dev/md$PLACE" >> /etc/raidtab     &&
echo "raid-level $RAIDLEVEL"   >> /etc/raidtab   &&
echo "nr-raid-disks $NR_DISCS" >> /etc/raidtab   &&
if [ "$RAIDLEVEL" = "5" ] || [ "$RAIDLEVEL" = "4" ] 
then echo "parity-algorithm left-symmetric" >> /etc/raidtab    
fi                                               &&
echo "persistent-superblock 1" >> /etc/raidtab   &&
echo -e "chunk-size 32 \n" >> /etc/raidtab       &&
i=0                                              && 
for line in `< /tmp/raid.parts`; do echo -e "\tdevice $line\n\traid-disk $i";((i++));done >> /etc/raidtab &&
echo " " >> /etc/raidtab                         
PROMPT="Finished making RAID devices ?"
if ! confirm "${PROMPT}"; then
   mk_raid_config
fi

}

#make_fstab: writes out the fstab...
# SECTION: DISK_STRUCTURE
make_fstab()  {
  cp -f /etc/installerdata/fstab ${TARGET}/etc/fstab &&
  if [[ `uname -r` == 2.6.* ]]
  then FLOPPY=fd0
       CDROM=`cat /proc/mounts | grep iso9660 | awk '{print $1}'`
       sed -i -e 's/\#sysfs/sysfs/' ${TARGET}/etc/fstab && mkdir ${TARGET}/sys
  else CDROM=/dev/cdroms/cdrom0
       FLOPPY=floppy/0
  fi 
  echo  -e  "$FS_LIST"  >>  "${TARGET}/etc/fstab"


  echo -e "$CDROM  /mnt/cdrom   auto  defaults,noauto,user  0 0" >> "${TARGET}/etc/fstab"
  echo -e "/dev/$FLOPPY       /mnt/floppy  auto  defaults,noauto,user  0 0" >> "${TARGET}/etc/fstab"
  
}

# 10/09/2003 The code for optimize_architecture(), architecture_menu()
# and optimization_menu() has been adapted from /usr/sbin/sorcery
# version 1.3 (Benoit PAPILLAULT)
# TODO: could this be sourced from the actual sorcery script?
# SECTION: SOFTWARE_CONFIG
optimize_architecture() {

    architecture_menu  ARCHITECTURE  "Build system selection"    &&
    if [[ $CROSS_INSTALL == on ]]; then
        architecture_menu  TARGET      "Target system selection"
    fi                                                           &&
    optimization_menu                                            &&

# next stop kernel config
[ -n "$GUIDE" ] && ICOMMAND="K"

}

# architecture_menu: displays an architecture menu
# TODO: also comes from sorcery?
# SECTION: SOFTWARE_CONFIG
architecture_menu() {

    local  SPECFILE
    local  LIST
    local  IDX=0
    alias use_gcc2=false

    for  SPECFILE  in  `find  ${ARCH_SPECS} -not  -name '*~' | sort`;
      do
      if  [[  -x  $SPECFILE  ]]  && grep  -q  "CPUNAME"  $SPECFILE
      then
          local CPUNAME=""
          CPUNAME=$( .  $SPECFILE  &&  echo $CPUNAME )  &&
          LIST[$((IDX++))]=`basename "${SPECFILE}"`
          LIST[$((IDX++))]=${CPUNAME}
          LIST[$((IDX++))]=${CPUNAME}
      fi
    done
    
    local ARCH_TITLE="$2"
    local ARCH_HELP="Please select a microprocessor category"

    ARCHITECTURE=`"${DIALOG[@]}" --title  "$ARCH_TITLE"     \
                               --item-help                \
                               --no-cancel                \
                               --menu                     \
                               "$ARCH_HELP"               \
                               7 60 0                     \
                               "${LIST[@]}"`              &&

        echo -e ARCHITECTURE=\"$ARCHITECTURE\" >>${TARGET}/etc/sorcery/local/config 

}

#optimization_menu : Displays the menu to select optimizations
# TODO: can this come from the sorcery file/libs/etc?
# SECTION: SOFTWARE_CONFIG
optimization_menu() {
    # default flags
    SPEEDY=on
    COMBRELOC=on
    STRIP=on

    local OPTIMIZATIONS
    local      OPT_TITLE="Optimization Menu"
    local       OPT_HELP="Please select optimizations"
    
    local    SPEEDY_HELP="Optimize to increase performance of generated code (safe)"
    local     RISKY_HELP="Optimize to increase performance ... by violating ANSI or IEEE rules"
    local      TINY_HELP="Optimize to decrease size of generated code (safe)"
    local     STRIP_HELP="Remove all symbol table and relocation (debugging) information"
    local COMBRELOC_HELP="Speeds up loading libs, also needed for prelink (safe)"

  OPTIMIZATIONS=`"${DIALOG[@]}" --title  "$OPT_TITLE"           \
                               --no-cancel               \
                               --item-help               \
                               --separate-output         \
                               --checklist               \
                               "$OPT_HELP"               \
                               7 60 0                    \
  "speedy"    "  +size  ++speed"  "$SPEEDY"    "$SPEEDY_HELP"    \
  "risky"     "          +speed"  "$RISKY"     "$RISKY_HELP"     \
  "combreloc" "         ++speed"  "$COMBRELOC" "$COMBRELOC_HELP" \
  "tiny"      "  -size"           "$TINY"      "$TINY_HELP"      \
  "strip"     " --size"           "$STRIP"     "$STRIP_HELP"`    &&

        OPTIMIZATIONS=`echo  ${OPTIMIZATIONS}  |  tr  '\n'  ' '`                         &&

        echo -e OPTIMIZATIONS=\"$OPTIMIZATIONS\" >> ${TARGET}/etc/sorcery/local/config   &&
    

  MAKE_JOBS=`"${DIALOG[@]}" --title "Enter the number jobs for cast to run" \
	  --inputbox "The number of CPUs + 1 is a good way to keep the
processor optimised during casts" 9 60 1`     &&

echo MAKE_NJOBS=$MAKE_JOBS > ${TARGET}/etc/sorcery/local/compile_config                  &&

 # if it isn't -x sorcery won't read it
chmod a+x ${TARGET}/etc/sorcery/local/compile_config

}

# this function use ROOT, BOOT and MBR variables to
# determine the device where the bootloader must be
# installed.

# Example: ROOT=/dev/hda6, BOOT=/dev/hda5, MBR=yes => /dev/hda
#          ROOT=/dev/hda6, BOOT=/dev/hda5, MBR=no  => /dev/hda5

# usage: BR=`bootloader_get_br`
#SECTION: BOOTLOADER_CONFIG
bootloader_get_br() {

  # if BOOT is not defined, we use ROOT
  BOOT="${BOOT:=${ROOT}}" &&

  case "${MBR}" in
    yes)
	  echo "${BOOT}" |
	  sed -e 's/part[0123456789]*$/disc/' -e 's/[0123456789]*$//'
	  ;;

	no)
	  echo "${BOOT}"
	  ;;

    *)
      # if we are here, MBR has a wrong value. use $BOOT anyway...
	  echo "${BOOT}"
  esac

}

# return the installed kernel version (either precompiled or compiled)
# it returns for instance 2.6.8.1
# SECTION: BOOTLOADER_CONFIG
bootloader_get_kernel() {

  chroot_cmd gaze version linux | head -3 | tail -1 | awk '{print $5}'

}

#SECTION: BOOTLOADER_CONFIG
bootloader_grub_conf() {

  mkdir -p "${TARGET}/boot/grub" &&

  # if BOOT is not defined, we use ROOT
  BOOT="${BOOT:=${ROOT}}"

  # create a /boot/grub/menu.lst configuration file

  if [ "${BOOT}" != "${ROOT}" ]; then
    BOOTLOC=""
  else
	BOOTLOC=/boot
  fi

  LINUX=`bootloader_get_kernel`

  #TODO: store the default information in a default file not here!
  cat > "${TARGET}/boot/grub/menu.lst" <<EOF
#
# /boot/grub/menu.lst generated by the Source Mage GNU/Linux installer
# on `date --utc`
#

# Boot automatically after 30 secs.
timeout 10

# By default, boot the first entry.
default 0

# Fallback to the second entry.
fallback 1

# Splashimage, provides a nice image for the background
splashimage ${BOOTLOC}/grub/images/smgl-splash.xpm.gz

# defines menu foreground/background, highlight foreground/background
color  black/light-gray white/red

title  Source Mage GNU/Linux ${LINUX}
kernel ${BOOTLOC}/vmlinubz-${LINUX} root=${ROOT} ro
#initrd ${BOOTLOC}/initrd.img-${LINUX}.gz

EOF

}

#bootloader_grub_edit : displays a menu request if they want to configure 
# the boot loader by hand. Then display's the default editor, usually nano, or elvis
# SECTION: BOOTLOADER_CONFIG
bootloader_grub_edit() {

  S_GRUB="Source Mage GNU/Linux by default installs GRUB to the
first sector of /boot.  If you prefer that GRUB be
installed to the MBR, Master Boot Record, then return
to the main menu, rerun \"Configure ${BOOTLOADER}\" and
choose to install to the MBR. MBR for RAID 1 arrays is
the first disk in the array, unless a separate /boot
partition is made.  You may now view/edit the generated
grub.conf."

  "${DIALOG[@]}" \
	--no-label "Return" --yes-label "Continue" --nocancel \
	--yesno "${S_GRUB}" 12 60 &&

  EDITOR="${EDITOR:-nano}"                                        &&
  ${EDITOR} "${TARGET}/boot/grub/menu.lst"                        &&
  echo "grub configuration file edited" >> /tmp/installer-debug

}

#actually does the install for GRUB
# SECTION: BOOTLOADER_CONFIG
bootloader_grub_install() {

  # get boot record

  BR=`bootloader_get_br`

  # display debug information

  if [ "${DEBUG}" = "yes" ]; then
	echo "MBR=${MBR} ROOT=${ROOT} BOOT=${BOOT} BR=${BR}"
	press_enter
  fi

  # install grub (it is a shell script using df, and thus /etc/mtab to
  # locate file)

  cp "${TARGET}/etc/fstab" "${TARGET}/etc/mtab" &&
  chroot_cmd grub-install "${BR}"

  if [ "${DEBUG}" = "yes" ]; then
    press_enter
  fi

}

# SECTION: BOOTLOADER_CONFIG
bootloader_lilo_conf() {

  # if BOOT is not defined, we use ROOT

  BOOT="${BOOT:=${ROOT}}"

  # get the linux kernel version

  LINUX=`bootloader_get_kernel`

  # get the boot record partition

  BR=`bootloader_get_br`

  # display information in debug mode

  if [ "${DEBUG}" = "yes" ]; then
	echo "MBR=${MBR} ROOT=${ROOT} BOOT=${BOOT} BR=${BR}"
	press_enter
  fi

  # copy boot.bmp

  cp -a /boot/boot.bmp "${TARGET}/boot/boot.bmp"

  # create a configuration file
  # TODO: move default lilo.conf into a default file not in here
  mkdir -p "${TARGET}/etc" &&
  cat > "${TARGET}/etc/lilo.conf" <<EOF
boot=${BR}
root=${ROOT}

prompt
# lba32
delay=128
timeout=128
install=boot-bmp.b
bitmap=/boot/boot.bmp
bmp-table=227p,233p,1,7
bmp-colors=13,0,,11,0,13
bmp-timer=76,30,11,0
map=/boot/map

image=/boot/vmlinubz-${LINUX}
    label=linux-${LINUX}
    read-only

EOF

}

# displays a menu to config LILO
#SECTION: BOOTLOADER_CONFIG
bootloader_lilo_edit() {

  local MSG="SMGL installs LILO to the first sector of /boot.  If
you prefer that LILO be installed to the MBR, Master
Boot Record, then edit /etc/lilo.conf and change the
boot= so that the last word is disc instead of part?.
For RAID 1 arrays change boot= to a disc in the array
or even the first disk on the machine"

  "${DIALOG[@]}" --msgbox "${MSG}" 11 60 &&

  EDITOR="${EDITOR:-nano}" &&
  ${EDITOR} "${TARGET}/etc/lilo.conf" &&
  echo "lilo configuration file edited" >> /tmp/installer-debug

}

# SECTION: BOOTLOADER_CONFIG
bootloader_lilo_install() {

  chroot_cmd lilo -v

  if [ "${DEBUG}" = "yes" ]; then
    press_enter
  fi

}

# SECTION: BOOTLOADER_CONFIG
bootloader_yaboot_conf() {

  # yabootconfig will df, df will use /etc/mtab
  # so, we need a valid /etc/mtab. copy /etc/fstab.

#  PROMPT="Do you want to execute yabootconfig in a chroot?"
#
#  if confirm "${PROMPT}" --defaultno; then
#
#    cp "${TARGET}/etc/fstab" "${TARGET}/etc/mtab" &&
#    chroot_cmd yabootconfig --noinstall -q
#
#  else

    # replace /boot/vmlinux if it is an absolute link

    if [ -h "${TARGET}/boot/vmlinux" ]; then
      LINK=`readlink "${TARGET}/boot/vmlinux"`
      if [ "${LINK:0:1}" = "/" ]; then
        ln -sf "..${LINK}" "${TARGET}/boot/vmlinux"
      fi
    fi

    yabootconfig -t "${TARGET}" --noinstall -q

#  fi

  # remove the default image section written by yabootconfig
  # which are the last 3 lines of /etc/yaboot.conf

  head -n -3 "${TARGET}/etc/yaboot.conf" > /tmp/yaboot.conf
  cp /tmp/yaboot.conf "${TARGET}/etc/yaboot.conf"

  if [ "${BOOT}" != "${ROOT}" ]; then
    BOOTLOC=""
  else
	BOOTLOC=/boot
  fi

  # get the linux kernel version

  LINUX=`bootloader_get_kernel`

  # add our own image section
  
  cat >> "${TARGET}/etc/yaboot.conf" <<EOF

image=${BOOTLOC}/vmlinux-${LINUX}
    label=linux-${LINUX}
    read-only

EOF

}

# SECTION: BOOTLOADER_CONFIG
# TODO: the message should be the same for all of them, er pretty close
bootloader_yaboot_edit() {

  local MSG="You can now reconfigure /etc/yaboot.conf. Feel free to
do it, at your own risk."

  "${DIALOG[@]}" --msgbox "${MSG}" 7 60

  EDITOR="${EDITOR:-nano}" &&
  ${EDITOR} "${TARGET}/etc/yaboot.conf" &&
  echo "yaboot configuration file edited" >> /tmp/installer-debug

}

#SECTION: BOOTLOADER_CONFIG
bootloader_yaboot_install() {

  # we use --nonvram since we don't have nvsetenv installed

  chroot_cmd ybin --nonvram

  if [ "${DEBUG}" = "yes" ]; then
    press_enter
  fi

}

# usage: chroot_install spell
# installs a spell into the chroot environ
chroot_install() {

# check if it's already installed then install it

  SPELL="$1"
  echo "Installing spell ${SPELL}"

  if ! grep -q "^${SPELL}:" "${TARGET}/var/state/sorcery/packages"; then

    # packages version:
    SPELL_STATUS="/var/state/sorcery/packages"

    VERSION=`grep "^${SPELL}:" "${SPELL_STATUS}" | cut  -d : -f4 | head  -n 1`
	if [ -z "${VERSION}" ]; then
	  echo "spell ${SPELL} is missing on CD"
	  return 1
	fi

	(cd "${TARGET}" &&
	  tar jxpf "/var/cache/sorcery/${SPELL}-${VERSION}"-*.tar.bz2)

    chroot_cmd ldconfig 2>> /tmp/installer-debug

    echo "chroot installing $*" >> /tmp/installer-debug     

    LINE=`grep "^${SPELL}:" "${SPELL_STATUS}"`
	echo "${LINE}" >> "${TARGET}/var/state/sorcery/packages"

  else
    echo "Spell ${SPELL} already installed"
  fi

}

# TODO: figure out what this does...
# SECTION: SYSTEM_CONFIG
chroot_newdep() {

# this is run after the default list is installed so it checks in the
# list of optional spells waiting before installing

            for newdep in `gaze DEPENDS $(echo $* | cut -d: -f1) | grep ^depends | awk '{print $2}' | sed -e 's/"//g'`
            do if ! `echo $OPTIONALS | grep -q '${newdep} '`
               then chroot_install $newdep
               fi
            done

}

# sets up the target system for the installer and such
#SECTION: SYSTEM_CONFIG
setup_target() {

# install sorcery to ${TARGET}
  tar -xjf /var/cache/sorcery/sorcery-stable.tar.bz2 -C /tmp
  pushd /tmp/sorcery
  ./install ${TARGET}
  popd
  rm -r /tmp/sorcery

# BIG HACK: make all directories we had previously relied on to magically appear

  mkdir -p ${TARGET}/etc/sorcery/local/depends
  mkdir -p ${TARGET}/var/spool/sorcery
  mkdir -p ${TARGET}/var/lib/sorcery/codex
  mkdir -p ${TARGET}/var/state/sorcery
  mkdir -p ${TARGET}/dev
  mkdir -p ${TARGET}/etc/init.d/runlevels
  mkdir -p ${TARGET}/sbin
  mkdir -p ${TARGET}/usr/bin
  mkdir -p ${TARGET}/bin
  mkdir -p ${TARGET}/lib
  mkdir -p ${TARGET}/proc
  mkdir -p ${TARGET}/root
  mkdir -p ${TARGET}/etc/sysconfig

# hack in case grimoire linux is behind the installer
  echo "Adding KERNEL_VERSION  to ${TARGET}/etc/sorcery/local/depends/linux" >> /tmp/installer-debug
  echo "KERNEL_VERSION=`uname -r`"  >> ${TARGET}/etc/sorcery/local/depends/linux
   
  echo "Adding sources to ${TARGET}/var/spool/sorcery" >> /tmp/installer-debug
  cp -f /var/spool/sorcery/* ${TARGET}/var/spool/sorcery/ &

  echo "Adding grimoire files to $TARGET" >> /tmp/installer-debug
  cd "${TARGET}/var/lib/sorcery/codex" &&
  tar xjpf /var/lib/sorcery/codex/stable.tar.bz2 &&
  cd / 

  # installer uses "gaze version $*" so we need to make the grimoire
  # available for it too

  mount --bind "${TARGET}/var/lib/sorcery/codex" /var/lib/sorcery/codex

  echo "Adding grimoire to $TARGET/etc/sorcery/local/grimoire" >> /tmp/installer-debug
  echo "GRIMOIRE_DIR[0]=/var/lib/sorcery/codex/stable" > ${TARGET}/etc/sorcery/local/grimoire

  echo "Adding /var/state/sorcery/* files to $TARGET" >> /tmp/installer-debug
  cp  -f /var/state/sorcery/* ${TARGET}/var/state/sorcery
  rm ${TARGET}/var/state/sorcery/packages
  touch ${TARGET}/var/state/sorcery/packages

  echo "Generating /etc/fstab ... " >> /tmp/installer-debug
  make_fstab 
  mkdir -p ${TARGET}/mnt/{floppy,cdrom}

  # add the installation's date in /etc/sourcemage_version

  local FILE=/etc/sourcemage_version
  echo "Adding installation date to ${FILE}..." >> /tmp/installer-debug
  cp "${VERSION}" "${TARGET}/${FILE}" &&
  echo "installed from CD on `date --utc`" >> "${TARGET}/${FILE}"

# copy these files as they are untracked or SA generated
  echo "Adding /etc/* files to $TARGET" >> /tmp/installer-debug
  cp -f /etc/{passwd,group,ld.so.conf,services,protocols,issue,modules,modules.conf,nsswitch.conf,yp.conf} ${TARGET}/etc
  echo "Symlinking ${TARGET}/etc/init.d/runlevels/rc to /bin/true" >> /tmp/installer-debug
  ln -sf /bin/true ${TARGET}/etc/init.d/runlevels/rc

# setup libc tar and bzip2 so that chroot_install will work immediately
  echo "Adding tar, bzip2, libc, libpthread and librt  to $TARGET" >> /tmp/installer-debug
  cp -f /sbin/ldconfig ${TARGET}/sbin
  cp -f /usr/bin/bzip2 ${TARGET}/usr/bin
  cp -f /bin/tar ${TARGET}/bin
  cp -af /lib/{ld-*,libpthread*,libc.so.6,libc-*,librt*} ${TARGET}/lib
  # have already copied /etc/ld.so.conf , so ...
  chroot_cmd ldconfig

# adding root's config files to ${TARGET}
  cp -f /etc/skel/.* ${TARGET}/root/
  # secure default for the history file
  ln -sf /dev/null ${TARGET}/root/.bash_history

# setup the static /dev/ entries while the user configures the rest of the install
  echo "Setting up static /dev entries" >> /tmp/installer-debug
  if [ -f /sbin/MAKEDEV ]; then
    cp -f /sbin/MAKEDEV "${TARGET}/dev" &&
	(cd "${TARGET}/dev" &&
	  ./MAKEDEV generic md &&
	  mknod initctl p &&
	  mkdir -p {pts,shm})
  else
	echo "/sbin/MAKEDEV is missing"
  fi       
}

# usage : optional_spell_list
# output: for each spell, output 3 lines : spell name, spell
# description and "off"
# Generates the spell list...
#TODO: this should be pregenerated, because it doesn't change after the iso
# is made
# SECTION: SYSTEM_CONFIG
optional_spell_list () {

  cat /etc/installerdata/optional-list | \
  while read spell;
  do
    echo "${spell}"
    echo `gaze short "${spell}" | tail -n +2`
    echo off
  done

}

# displays the screen that allows to select optional spells
# SECTION: SYSTEM_CONFIG
choose_optionals() {

  IFS=$'\n' OPTIONAL_SPELL_LIST=( `optional_spell_list` )

  TITLE="Installer menu for selecting optional spells to install."

  HELP="Please select from the list of optional spells
available. Dependencies will be added later if a spell
needs them."

  "${DIALOG[@]}" \
	  --title     "$TITLE" \
	  --separate-output    \
	  --checklist "$HELP"  \
	  9 60 0             \
	  "${OPTIONAL_SPELL_LIST[@]}"

}

# goes through things for optional configs
# udev or static is in here
# optional spell list is in here
# SECTION: SYSTEM_CONFIG
spell_select() {

  echo "Sorcery is generating the optional spell menu, please wait ..." &&
  echo "Generating menu for optional spells" >> /tmp/installer-debug    &&

  # check that setup_target has atleast copied over the binaries for
  # chroot_install to work, otherwise sleep

  while ! [ -e ${TARGET}/etc/ld.so.cache ] 
  do echo "Waiting for setup to finish"
    sleep 2
  done && 

  OPTIONALS=`choose_optionals` &&

  if [[ `uname -r` == 2.6.* ]]; then

	PROMPT="Would you like to run udev on /dev or traditional
static /dev ?"

	if "${DIALOG[@]}" --no-label "static" --yes-label "udev" --nocancel \
		--yesno "${PROMPT}" 6 60; then
	  DEVICES="udev"
    else
	  DEVICES="static"
    fi
    echo "chose ${DEVICES} for /dev" >> /tmp/installer-debug
fi    &&

# next stop last screen and installation

[ -n "$GUIDE" ] && DONE_CONFIG="YES"

echo "Optionally chose $OPTIONALS for installation" >> /tmp/installer-debug

}

# generates the list of available/installed services
# SECTION: SYSTEM_CONFIG
service_list() {

ALLSCRIPTS=`find ${TARGET}/etc/init.d/runlevels/%*/ | grep -v runlevel.config`
for initscript in $ALLSCRIPTS
do if [ -f $initscript ]
   then echo "`echo $initscript | cut -d/ -f8` "
        echo "Runlevel `echo $initscript | cut -d/ -f7 | sed s:%::`"
        if [ -x $initscript ]
        then echo "on"
        else echo "off"
        fi
  fi
done

}

# displays the menu to select services
# SECTION: SYSTEM_CONFIG
service_choose() {

  TITLE="Installer menu for selecting initscripts to run at boot."

  HELP="Please select from the list of initscripts
available. An X means they are currently enabled (maybe
for a good reason !)."

  IFS=$'\n' SERVICE_LIST=( `service_list` )

  "${DIALOG[@]}"  --title     "$TITLE"     \
           --separate-output        \
           --checklist "$HELP"      \
           9 60 0                   \
	  "${SERVICE_LIST[@]}"

}

# actually does the work involved with selecting services
# SECTION: SYSTEM_CONFIG
service_select() {
 
echo "Running menu selection of services to start at boot" >> /tmp/installer-debug &&
SERVICES=`service_choose` &&
for initscript in $(echo ${TARGET}/etc/init.d/runlevels/%*/* | tr ' ' '\n' | grep -v runlevel.config | cut -d/ -f8)
do if echo $SERVICES | grep -q "$initscript "
   then chroot_cmd telinit bootenable "$initscript" > /dev/null
        echo "Marking $initscript to start at boot ..."
   else chroot_cmd telinit bootdisable "$initscript" > /dev/null
        echo "Disabling starting of $initscript at boot ... " 
   fi
done        &&

[ -n "$GUIDE" ] && ICOMMAND="X"

}

# usage : IFS=$'\n' FS_PROGS=( `get_fs_progs` )
# return a list of all spells needed for the filesystem in /etc/fstab
# SECTION: SYSTEM_CONFIG
get_fs_progs() {

  # check which fs spells are needed
  # ext2      -> e2fsprogs
  # ext3      -> e2fsprogs
  # reiserfs  -> reiserfsprogs
  # swap      -> none needed
  # xfs       -> xfsprogs
  # jfs       -> jfsutils

  # grep -v "^#" : remove comments
  # awk '{print $3}' : select only the fstype field
  # sort -u : does a unique sort

  cat "${TARGET}/etc/fstab" | grep -v "^#" | awk '{print $3}' | sort -u |
  while read fstype;
  do
	case "${fstype}" in
	  ext2)     echo e2fsprogs    ;;
	  ext3)     echo e2fsprogs    ;;
	  reiserfs) echo reiserfsprogs;;
	  xfs)      echo xfsprogs     ;;
	  jfs)      echo jfsutils     ;;
	  swap)                       ;;
    esac
  done

  if cat "${TARGET}/etc/fstab" | awk '{print $1}' | grep -q md ; then
    if [ -s /etc/raidtab ]; then
      cp -f /etc/raidtab "${TARGET}/etc/raidtab"
	  echo raidtools
    fi
  fi

}

#does the actual installing ito the target
# SECTION: SYSTEM_CONFIG
install_to_target()  {

  PROMPT="Are you ready to install ?"

  if  confirm  "${PROMPT}"; then
    echo  "Installing Source Mage GNU/Linux."

    # now install the default spells 

	cat /etc/installerdata/install-list | \
	while read spell;
	do
	  if [ -z "${spell}" ]; then
		# we have a blank line, ignore it
		continue
      fi
      chroot_install "${spell}"
    done &&
       
    # make network the network provider
	sed -i -e s/network=.*/network=network/ ${TARGET}/etc/sysconfig/facilities

    # reinstall the /etc/resolv.conf in case downloading is wanted for
    # compile_kernel

	cp -f /etc/resolv.conf ${TARGET}/etc/

	IFS=$'\n' FS_PROGS=( `get_fs_progs` )
       
    # install the used fs spells
	for fsinstall in "${FS_PROGS[@]}";
	do
	  if [ "${DEBUG}" = "yes" ]; then
		echo "chroot_install ${fsinstall}"
		press_enter
	  fi
	  chroot_install "${fsinstall}"
	  chroot_newdep  "${fsinstall}"
	done

	echo "Installed filesystem spells ${FS_PROGS[@]}" >> /tmp/installer-debug

    # install EDITOR LOGGER and the networking spells 
	chroot_install ${REAL_ED}
	# TODO: figure out what this means...
	chroot_newdep ${REAL_ED} #frikkin jed and slang !

	# install the bootloader
	chroot_install "${BOOTLOADER}"

	if [[ $LOGGER != none ]]; then
	  chroot_install $LOGGER
	  chroot_newdep  $LOGGER
	  [[ $LOGGER == metalog ]] && sed -i -e s/syslog=/syslog=smgl-$LOGGER/ ${TARGET}/etc/sysconfig/facilities
	  [[ $LOGGER == sys* ]] && sed -i -e s/syslog=/syslog=$LOGGER/ ${TARGET}/etc/sysconfig/facilities
	fi

    # install the required networking spells

	echo "Installing networking spells; $NETTAGE" >> /tmp/installer-debug  
	for netspell in `echo $NETTAGE|tr ' ' '\n'` ;
	do
	  chroot_install $netspell
	  chroot_newdep  $netspell
	  [[ "$netspell" == *ppp* ]] && cp -af /etc/ppp ${TARGET}/etc/
	done

    # install the optional spells that were selected

	for extraspell in `echo $OPTIONALS | tr ' ' '\n'`;
	do
	  chroot_install $extraspell
	  chroot_newdep $extraspell
	  # TODO: move things like this into a folder and just run through
	  # TODO: the folder and run the stuff like xinetd or something
	  if [[ $extraspell == openssh* ]]; then
        mkdir -p ${TARGET}/etc/xinetd.d
		cp -f /etc/xinetd.d/openssh ${TARGET}/etc/xinetd.d
		mkdir -p ${TARGET}/etc/ssh
		
               # hehe want the keys to be unique, not same on every
               # $VERSION install :) this is same as openssh's
               # Makefile running "make host-key"
		
		rm -f /etc/ssh/*host*
		ssh-keygen -t rsa1 -f /etc/ssh/ssh_host_key -N ""
		ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key -N ""
		ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key -N ""
		cp -af /etc/ssh/* ${TARGET}/etc/ssh/
	  fi
	  [[ $extraspell == devfsd* ]] && cp -f /etc/devfsd.conf ${TARGET}/etc/
	  [[ $extraspell == xinetd* ]] && cp -f /etc/xinetd.conf ${TARGET}/etc/ && mkdir -p ${TARGET}/var/log/xinetd
	  [[ $extraspell == distcc* ]] && chroot_install xinetd && cp -f /etc/xinetd.d/distccd ${TARGET}/etc/xinetd.d && \
          echo "distcc		3632/tcp" >>${TARGET}/etc/services && mkdir -p ${TARGET}/var/log/xinetd
	  [[ $extraspell == links* ]] && chroot_install openssl 
	  [[ $extraspell == uptimed* ]] && mkdir -p ${TARGET}/var/spool/uptimed/ 
	done
	if grep -q portmap ${TARGET}/var/state/sorcery/packages; then
	  sed -i -e 's/^portmap=.*$/portmap=portmap/' ${TARGET}/etc/sysconfig/facilities
	fi &&
    # install udev if DEVICES=udev
	if [ "${DEVICES}" = "udev" ]; then
      chroot_install udev
	  chroot_newdep  udev
	  chroot_install which
	fi &&

	touch                                ${TARGET}/proc/mounts

    # installing the keymap chosen in keymap_menu() or the default one: us

    KEYMAP=${KEYMAP:-us}
    sed -i -e  s/KEYMAP=.*/KEYMAP=${KEYMAP}/  ${TARGET}/etc/sysconfig/keymap &&

 # install the users choice of editor ($REAL_ED) to the system profile.d dir
 # TODO: things like this should be optional/configurable
 # TODO: create a /profile.d directory to copy from with stuff like that

	cat >> "${TARGET}/etc/profile.d/editor.sh" <<EOF &&
#!/bin/bash
# Added by $0
# First check if this variable is already set
# then if not set, check it (maybe), then set it

if  [ -z "\$EDITOR" ] ; then
        EDITOR="$REAL_ED"
fi
export EDITOR

EOF

# installing the chosen LANG to the system profile.d dir
#TODO: same thing here should be an external file that's processed
    cat >> "${TARGET}/etc/profile.d/lc.sh" <<EOF &&
#!/bin/bash
# Added by $0
# First check if this variable is already set
# then if not set, check it (maybe), then set it

if  [ -z "\$LANG" ] ; then
        LANG="$LANG"
fi
export LANG

EOF

	# if the user wants a precompiled kernel, copy it now

    if [ "${KERNEL}" = "copy" ]; then
      chroot_install linux
    fi

    if [[ `uname -r` == 2.6.* ]]; then
      sed -i -e s/DEVICES=.*/DEVICES=$DEVICES/ ${TARGET}/etc/sysconfig/devices
    else
	  sed -i -e s:/dev/tty:/dev/vc/: ${TARGET}/etc/inittab
    fi &&

    # TODO: system is installed, but kernel isn't compiled?
    # TODO: should kernel be compiled here?
	S_INSTALLED="The system and your chosen spells have been installed
to ${TARGET}. Next enter the password for the root
account and if you chose to compile a kernel, that
happens last."

    "${DIALOG[@]}" --msgbox "${S_INSTALLED}" 9 60

    # TODO: not really part of install, but part of config
	echo "Last thing to do: choose root password:" 
    chroot_cmd passwd root
  fi &&
  echo "chrooting and changing root password" >> /tmp/installer-debug

  # if the user wants to compile his own kernel, do it now

  if [ "${KERNEL}" = "compile" ]; then
	compile_kernel
  fi

  DONE_INSTALLED=yes

  # we install the bootloader, erasing any previous configuration

  bootloader_${BOOTLOADER}_conf
  bootloader_${BOOTLOADER}_install

  [ -n "$GUIDE" ] && ICOMMAND="U"

}

# displays the menu for what to do about a kernel
# SECTION: SYSTEM_CONFIG
make_kernel()  {

  # install the config used for this kernel
  cp -f /boot/config* ${TARGET}/etc/sorcery/local/ISO-kernel.config

  COMPILE_HELP="A custom kernel might be needed for your hardware
               needs"

  COPY_HELP="The default kernel is extrememly modular."

  TITLE="Installer menu for kernel installation for x86."

  HELP="Would you like to configure and compile a custom
kernel, or install the precompiled kernel from the ISO
? (Actual compilation/copying will happen after the
spell installation)"

  KERNEL=`"${DIALOG[@]}"  \
	  --title "${TITLE}"  \
	  --item-help         \
	  --radiolist "$HELP" \
	  10 60 0             \
	  "compile" "custom built $(uname -r) kernel" "off" "$COMPILE_HELP" \
	  "copy"    "precompiled $(uname -r) kernel"  "on"  "$COPY_HELP"`   &&
  KERNEL=`echo "${KERNEL}" | sed -e 's/^"//' -e 's/"$//'`
  if [ "${DEBUG}" = "yes" ]; then
	echo "KERNEL=${KERNEL}"
	press_enter
  fi &&

# next stop logger config
# TODO: Self motivated menu
  [ -n "$GUIDE" ] && ICOMMAND="L"

}

# does cast  -c linux
# SECTION: SYSTEM_CONFIG
compile_kernel() {

  "${DIALOG[@]}"  --cr-wrap --textbox  /etc/installerdata/kernel.help 22 60
  rm -rf "${TARGET}/usr/src/linux"*
  chroot_cmd cast -c linux &&
  echo "compiling custom kernel" >> /tmp/installer-debug

  # the bootloader will be reinstalled later...

}

# shells out
# SECTION: MISC
shell() {

  echo  "Press CTRL-D or type exit to return to the installer"
  /bin/sh

}

# asks questions for network connectivity
# SECTION: NETWORK_CONFIG
ethernet()  {

       DHCPCD_PROMPT="Will you require DHCPCD ?"
     PCMCIA_PROMPT="Will you require PCMCIA ?"
     WIRELESS_PROMPT="Will you require wireless_tools ?"

  if  confirm  "${PCMCIA_PROMPT}" --defaultno ;  then
      NETTAGE="$NETTAGE pcmcia-cs"
  fi &&
  
  if  confirm  "${DHCPCD_PROMPT}" --defaultno ;  then
      NETTAGE="$NETTAGE dhcpcd"
  fi &&
  
  if  confirm  "${WIRELESS_PROMPT}" --defaultno ;  then
      NETTAGE="$NETTAGE wireless_tools"
  fi &&

  # configure netconf on the CD (requires a writable /etc) and next
  # copy the configuration to the target.

  # as a workaround to bug #7459, we launch netconf in an empty dir.
  # see : http://bugs.sourcemage.org/show_bug.cgi?id=7459

  mkdir -p /tmp/empty-dir &&
  cd /tmp/empty-dir &&
  netconf &&
  cp -af /etc/sysconfig/network "${TARGET}/etc/sysconfig" &&
  echo "Running netconf" >> /tmp/installer-debug &&

PROMPT="Start that interface now ?" 
if confirm "${PROMPT}"; then
  telinit run network restart
  cp -f /etc/resolv.conf  ${TARGET}/etc/       &&
  echo "starting ethernet interface" >> /tmp/installer-debug
else
  echo "declined to start ethernet interface" >> /tmp/installer-debug
fi

}

# configuration menu for ppp
# SECTION: NETWORK_CONFIG
ppp()  {
     unset NETTAGE
     DHCPCD_PROMPT="Will you require DHCPCD ?"           &&
     PCMCIA_PROMPT="Will you require PCMCIA ?"           &&
     WIRELESS_PROMPT="Will you require wireless_tools ?" &&
     PPPOE_PROMPT="Will you require rp-pppoe ?"          &&
     
  if  confirm  "${PCMCIA_PROMPT}" --defaultno ;  then
      NETTAGE="$NETTAGE pcmcia-cs"
  fi &&
    if confirm  "${DHCPCD_PROMPT}" --defaultno ;  then
      NETTAGE="$NETTAGE dhcpcd"
  fi &&
  if confirm "${WIRELESS_PROMPT}" --defaultno ; then
     NETTAGE="$NETTAGE wireless_tools"
  fi &&
  if confirm "${PPPOE_PROMPT}" --defaultno ; then
      NETTAGE="$NETTAGE rp-pppoe"
  fi &&

  USERNAME_PROMPT="Enter ISP username"
  PASSWORD_PROMPT="Enter ISP password"
    NUMBER_PROMPT="Enter ISP phone number without dashes, spaces and parenthesis"
      PORT_PROMPT="Enter serial port device"
              ISP="/etc/ppp/chat/isp"

         USERNAME=`inputbox  "$USERNAME_PROMPT"`             &&
         PASSWORD=`inputbox  "$PASSWORD_PROMPT"`             &&
           NUMBER=`inputbox  "$NUMBER_PROMPT"    "5555555"`  &&
             PORT=`inputbox  "$PORT_PROMPT"      "ttyS0"`    &&

  sed -i -e "s/5555555/$NUMBER/"             "$ISP"             &&
  sed -i -e "s/: username/: $USERNAME/"      "$ISP"             &&
  sed -i -e "s/qpassword/q$PASSWORD/"        "$ISP"             &&
  ln  -sf  $PORT  $TARGET/dev/modem                             &&
  ln  -sf  $PORT  /dev/modem                                    &&
  

PROMPT="Start that interface now ?"                       &&
if confirm "${PROMPT}"; then
  pon isp
  cp -f /etc/resolv.conf  ${TARGET}/etc       &&
  echo "starting ppp interface" >> /tmp/installer-debug
else
  echo "declined to start ppp interface" >> /tmp/installer-debug
fi

}

# configuration menu and actions for pppoe
# SECTION: NETWORK_CONFIG
pppoe()  {
        unset NETTAGE

     DHCPCD_PROMPT="Will you require DHCPCD ?"
     PCMCIA_PROMPT="Will you require PCMCIA ?"
     WIRELESS_PROMPT="Will you require wireless_tools ?"

  if  confirm  "${PCMCIA_PROMPT}" --defaultno ;  then
      NETTAGE="$NETTAGE pcmcia-cs"
  fi &&
  
  if  confirm  "${DHCPCD_PROMPT}" --defaultno ;  then
      NETTAGE="$NETTAGE dhcpcd"
  fi &&
  
  if  confirm  "${WIRELESS_PROMPT}" --defaultno ;  then
      NETTAGE="$NETTAGE wireless_tools"
  fi &&

  adsl-setup &&
  echo "Setting up adsl via adsl-setup" >> /tmp/installer-debug &&

PROMPT="Start that interface now ?"  &&
if confirm "${PROMPT}"; then
  adsl-start
  cp -f /etc/resolv.conf  ${TARGET}/etc       &&
  echo "starting adsl interface" >> /tmp/installer-debug
else
  echo "declined to start adsl interface" >> /tmp/installer-debug
fi


}

# displays menu to select a syslog
#SECTION: SYSTEM_CONFIG
syslog()  {

  TITLE="Please select your system logger"
  HELP="There are 3 loggers available"
  SYSKLOGD_HELP="This version of syslogd is similar to the standard Berkeley product."
  SYSLOGNG_HELP="syslog-ng, as the name shows, is a syslogd replacement."
  METALOG_HELP="Metalog is a modern replacement for syslogd and klogd."
  NONE_HELP="Don't want a logger, or don't know which one to pick."

  LOGGER=`"${DIALOG[@]}" \
	  --title "$TITLE"   \
	  --item-help        \
	  --radiolist        \
	  "$HELP"            \
	  7 60 0             \
	  "sysklogd"  "" "off" "$SYSKLOGD_HELP" \
	  "syslog-ng" "" "off" "$SYSLOGNG_HELP" \
	  "metalog"   "" "off" "$METALOG_HELP"  \
	  "none"      "" "off" "$NONE_HELP"`    &&
  LOGGER=`echo "${LOGGER}" | sed -e 's/^"//' -e 's/"$//'` &&
  export LOGGER                                           &&

  echo "Chose $LOGGER for the system logger" >> /tmp/installer-debug  &&

# next stop bootloader config

  [ -n "$GUIDE" ] && ICOMMAND="M"

}

# top level network config selection and actions
# SECTION: NETWORK_CONFIG
network()  {

    # chroot call netconf to configure hostname (we need to remove the
    # file /etc/hostname first)

    rm -f /etc/hostname &&
	netconf --check_hostname

    echo "hostname is `cat /etc/hostname`" >> /tmp/installer-debug
    cp -f /etc/hostname ${TARGET}/etc/hostname

    E_HELP="Use a network interface card, NIC?"
    P_HELP="Point to Point Protocol is for modem networking."
    R_HELP="Roaring Penguin PPP over Ethernet, for ADSL connections?"
  NET_HELP="How will this box connect to the Internet?"

  COMMAND=`"${DIALOG[@]}"  --title "Networking Protocol"  \
                    --nocancel                     \
                    --item-help                    \
                    --menu                         \
                    "$NET_HELP"                    \
                    7 60 0                         \
                    "E"  "Ethernet"  "$E_HELP"     \
                    "P"  "PPP"       "$P_HELP"     \
                    "R"  "PPPoE"     "$R_HELP"`    &&

  case  $COMMAND  in
    E)  ethernet  ;;
    P)  ppp       ;;
    R)  pppoe     ;;
  esac &&

# reset hostname to users
hostname `cat /etc/hostname` &&

# next stop select optional spells
[ -n "$GUIDE" ] && ICOMMAND="O"

}

# toggles guided menu
# SECTION: MISC
toggle_guide()  {

  [  -n  "$GUIDE"  ]  &&
  unset  GUIDE        ||
  GUIDE="on"

}

# toggles a confirm variable
# SECTION: MISC
toggle_confirm()  {

  [  -n  "$CONFIRM"  ]  &&
  unset  CONFIRM        ||
  CONFIRM="on"

}

# builds the list of all the available fonts
# SECTION: SYSTEM_CONFIG
show_consolefonts()  {

  FONTDIR="/usr/share/consolefonts"
  cd  $FONTDIR

  #TODO: the font list should be generated by the iso creation script
  #TODO: to make it faster...
  FONTS=`ls  *.gz  |  sed  "s/\.psf\.gz//"`

  for  FONT  in  $FONTS;  do
    echo  "${FONT}"
    echo  "font "
  done

}

#displays the menu for the font selection screen
# SECTION: SYSTEM_CONFIG
font_menu()  {

     TITLE="Console Font Selection Menu"
      HELP="Please select your preferred console fonts."
     FONTS=`show_consolefonts`
 
      FONT=`"${DIALOG[@]}"  --title  "$TITLE"   \
                     --menu   "$HELP"    \
                     7 60 0              \
                     $FONTS`             &&
  
  CONSOLECHARS="consolechars  -f  $FONT"  &&
  consolechars  -f  $FONT

}

# generates the languages list
# SECTION: SYSTEM_CONFIG
show_languages()  {
    IDX=0
	# TODO: this list should be auto generated by the ISO script
	# TODO:  that will make it faster and add a trivial amount of data
    cd /usr/share/i18n/locales
    for lang in *;
    do
      title=`grep "^title" "${lang}" | cut -d '"' -f 2`

      if [ -n "${title}" ]; then

          LANGS[$((IDX++))]="${lang}"
          LANGS[$((IDX++))]="${title} "

      fi
    done

}

# displays the language selection menu
# SECTION: SYSTEM_CONFIG
lang_menu()  {

    TITLE="Language Selection Menu"

     HELP="While sorcery is entirely in English it is possible to
change the languages of many other programs.  Please
select your preferred language."

     show_languages &&
     LANG=`"${DIALOG[@]}" \
		 --trim --title  "$TITLE"   \
		 --menu   "$HELP"    \
		 9 60 0              \
		 "${LANGS[@]}"` &&
    export LANG
    echo "Chose LANG=$LANG" >> /tmp/installer-debug
}

# displays the menu for editor installation selection
# SECTION: SYSTEM_CONFIG
editor_menu()  {

  ELVIS_HELP="elvis is a clone of the ex/vi text editor"
    JED_HELP="jed is an editor with emulation for emacs, EDT, and Wordstar"
   NANO_HELP="nano is an enchanced free pico clone"
    VIM_HELP="VIM is an improved version of vi"


        HELP="The Install/Rescue disc provides two easy to use
editors, elvis and nano. Four common editors can be
installed, although selecting jed or vim will still use
elvis during the install"

       TITLE="Editor Selection Menu"

  case "${EDITOR}" in
    vim)   VIM="on" ; ELVIS="off"; JED="off"; NANO="off";;
    elvis) VIM="off"; ELVIS="on" ; JED="off"; NANO="off";;
    jed)   VIM="off"; ELVIS="off"; JED="on" ; NANO="off";;
    nano)  VIM="off"; ELVIS="off"; JED="off"; NANO="on" ;;
    *)     VIM="off"; ELVIS="off"; JED="off"; NANO="off";;
  esac

  NEW_EDITOR=`"${DIALOG[@]}" --title  "$TITLE"      \
                   --item-help                      \
                   --default-item "${EDITOR}"       \
                   --radiolist   "$HELP"            \
                   10 60 0                          \
                   "vim"    "" "${VIM}"   "$VIM_HELP"    \
                   "elvis"  "" "${ELVIS}" "$ELVIS_HELP"  \
                   "jed"    "" "${JED}"   "$JED_HELP"    \
                   "nano"   "" "${NANO}"  "$NANO_HELP"` &&
  EDITOR=`echo "${NEW_EDITOR}" | sed -e 's/^"//' -e 's/"$//'`

  export  REAL_ED=$EDITOR
  export  EDITOR

  echo "chose $EDITOR as EDITOR" >> /tmp/installer-debug
 
}

# native language support
# determines customizeable things for this linux system
# SECTION: LOCALE_CONFIG
nls()  {

  while
    
      FONT_HELP="Select a new default console font."
    KEYMAP_HELP="Select a new default keyboard mapping. KEYMAP=$KEYMAP"
      LANG_HELP="Select a new default language. LANG=$LANG"
    EDITOR_HELP="Select a new default editor. EDITOR=$REAL_ED"
           HELP="Select the options to make your SMGL box more friendly."
          TITLE="Native Language Support Menu"

    COMMAND=`"${DIALOG[@]}"  --cancel-label  "Continue"                 \
                      --ok-label "Select"                       \
                      --title  "$TITLE"                          \
                      --item-help                                \
                      --menu  "$HELP"                            \
                      7 60 0                                     \
                      "Font"    "Font     Menu "  "$FONT_HELP"   \
                      "Keymap"  "Keymap   Menu "  "$KEYMAP_HELP" \
                      "Lang"    "Language Menu "  "$LANG_HELP"   \
                      "Editor"  "Editor   Menu "  "$EDITOR_HELP"`
  do
  
    case  $COMMAND in
        Keymap)  keymap_menu  ;;
          Font)  font_menu    ;;
          Lang)  lang_menu    ;;
        Editor)  editor_menu  ;;
    esac

  done

}

# builds a list of timezones
# TODO: this should be generated by ISO script
# SECTION: LOCALE_CONFIG
show_timezones()  {

  for  ITEM  in  `ls  $LOCALTIME/$1`;  do

    if  [  -n  "$1"  ];  then  echo  "$1/$ITEM"
                         else  echo     "$ITEM";  fi

    if  [  -d  $LOCALTIME/$1/$ITEM  ];  then  echo  "Directory "
                                        else  echo  "Timezone ";  fi
  done
  
}

# displays the timezone selection screen and does all the settings for it
# TODO: split apart display and selection from applying settings
# SECTION: SYSTEM_CONFIG
# TODO: the stuff in the background shouldn't be part of this function
# TODO: the background stuff should be fired off by the installer manager
timezone()  {

# being the first menu item after mounting, ask the user if it's ok to
# run setup_target in the background

  PROMPT="Are you done mounting file systems ? (Answering yes
means some system files and directories will be
installed in the background while you configure the
rest of the install)"

  if [ -z $DONE_SETUP ]; then
	if "${DIALOG[@]}" --yesno "${PROMPT}" 8 60; then
	  if ! echo $FS_LIST | grep -q swap; then
		PROMPT="Make swapfile, since you have no dedicated swap partition ?"
        if confirm "${PROMPT}"; then
          mk_swap_file
        fi
      fi 

# redirect errors to /dev/null and return shell to the installer

      setup_target 
	  read -p "press enter..."
      DONE_SETUP=yes
    else
      return 1
    fi
  fi       &&

  LOCALTIME="/usr/share/zoneinfo"
      TITLE="Time Zone Selection Menu"
       HELP="Select timezone or directory"
       ZONE=""

  while  TIMEZONES=`show_timezones  $ZONE` &&
         ZONE=`"${DIALOG[@]}"  --title  "$TITLE"  \
                        --menu             \
                        "$HELP"            \
                        7 60 0             \
                        $TIMEZONES`        &&
    [  -d  "${LOCALTIME}/${ZONE}"  ]

  do true
  done

  if  [ -f "${LOCALTIME}/${ZONE}" ]; then

# configure the local time zone
    ln  -sf  "${LOCALTIME}/${ZONE}" "${TARGET}/etc/localtime"
# and /etc/ is writable now too
    ln  -sf  "${LOCALTIME}/${ZONE}" /etc/localtime

    TITLE="GMT or Local"
     HELP="Does the hardware clock store time in GMT or local?\n\
GMT may cause incorrect time on systems like MS Windows."

    if "${DIALOG[@]}"  --title  "$TITLE"  \
                    --defaultno        \
                    --yes-label "GMT"  \
                    --no-label "Local" \
                    --yesno   "$HELP"  \
                    7 60 ;then
      UTC=yes
    else
      UTC=no
    fi

# select if the hardware clock is UTC or not
cat > ${TARGET}/etc/sysconfig/hwclock <<EOF
# does the hardware clock store the time in UTC
UTC=${UTC}
EOF
  echo "adding UTC=${UTC} to /etc/sysconfig/hwclock" >> /tmp/installer-debug
  fi     &&

# next stop architecture and opts
[ -n "$GUIDE" ] && ICOMMAND="H"

}


# usage: choose_bootloader()
# returns a string with the bootloader choosen : lilo/grub/yaboot
# displays a menu to select a bootloader
# SECTION: BOOTLOADER_CONFIG
choose_bootloader() {

  GRUB_HELP="GNU GRUB is a Multiboot boot loader. It was derived
from GRUB, GRand Unified Bootloader"

  LILO_HELP="lilo is a boot loader for Linux/x86 and other PC
operating systems."

  YABOOT_HELP="Yaboot is an OpenFirmware bootloader for Open Firmware
based machines. It works on NewWorld machines only."

  case "${ARCH}" in
	i386 | i486 | i586 | i686)

	  BOOTLOADER_LIST=( "grub" "GNU GRUB bootloader" "on"  "${GRUB_HELP}"
                        "lilo" "the LInux LOader"    "off" "${LILO_HELP}"   )

	  ;;

	ppc)

	  BOOTLOADER_LIST=( "yaboot" "Yaboot loader"     "on"  "${YABOOT_HELP}" )

	  ;;

	*)

	# this architecture is not yet supported.

	  ;;
  esac

  TITLE="Installer menu for selecting bootloader."

  HELP="Please select the bootloader for your machine."

  "${DIALOG[@]}" --title "$TITLE" \
	  --item-help             \
	  --radiolist "$HELP"     \
	  7 60 0                  \
	  "${BOOTLOADER_LIST[@]}" \
	  | sed -e 's/^"//' -e 's/"$//'

}

# applies the chosen bootloader
# SECTION: BOOTLOADER_CONFIG
config_bootloader() {

# if a bootloader has not been already choosen, do so.

  if [ -z "${BOOTLOADER}" ] ; then
    BOOTLOADER=`choose_bootloader`
	if [ "${DEBUG}" = "yes" ]; then
      echo "BOOTLOADER=${BOOTLOADER}"
	  press_enter
    fi
  fi                                                     &&

#  echo "Generating initial ramdisk. Please wait..." &&
#  ROOT="${ROOT}" OUTFILE="${TARGET}/boot/initrd.img-`uname -r`" mkinitrd-smgl \
#	> /dev/null &&

  # there is no MBR choice on ppc machines

  if [ "${ARCH}" != "ppc" ]; then

    PROMPT="Install ${BOOTLOADER} to the MBR of the /boot drive
(answer Yes) or to the boot sector of the /boot
partition (answer No) ?" &&

    if "${DIALOG[@]}" --defaultno --yesno "${PROMPT}" 7 60; then
      MBR="yes"
    else
      MBR="no"
	fi
  fi &&

  if [ "${DONE_INSTALLED}" = "yes" ]; then
	bootloader_${BOOTLOADER}_edit
	bootloader_${BOOTLOADER}_install
  fi

# next stop network config
  [ -n "$GUIDE" ] && ICOMMAND="N"

}

#displays the intallation help file
# SECTION: MISC
install_help()  {

  "${DIALOG[@]}" --cr-wrap --textbox /etc/installerdata/install.guide  21 60

}

# resets every variable and restarts the installation
# SECTION: MISC
restart_install() {
# unset all these
# ppc specific variables
       unset BD
       unset OFW
       unset RT
#common
       unset DEBUG
       unset FS_LIST
       unset FS_STRING
       unset FSTAB_ENTRY
       unset USED_FS
       unset UNUSED_FS
       unset EDITOR
       unset REAL_ED
       unset LANG
       unset UTC
       unset CLOCK
       unset MAP
       unset ZONE
       unset FONT
       unset KEYMAP
       unset ITEM
       unset LOCALTIME
       unset LINE
       unset LIST
       unset BOOT
       unset ROOT
       unset NETTAGE
       unset LOGGER
       unset PLACE
       unset RAIDLEVEL
       unset RAID_PARTS
       unset RD_PARTS
       unset RD_DISC
       unset ind_disk
       unset rd_device
       unset part
       unset raiddev
       unset RDEV
       unset MAKE_JOBS
       unset MAKE_NJOBS
       unset DONE_INSTALLED
       unset DONE_CONFIG
       unset DONE_SETUP
       unset extraspell
       unset default_spell
       unset spell
       unset fsinstall
       unset FS_PROG
       unset newdep
       unset OPTIONALS
       unset ALLSCRIPTS
       unset SERVICES
       unset initscript
       unset BOOTLOADER
       unset MBR
       unset BOOTLOC
       unset DEVICES
       unset SWAPON
       unset KERNEL

umount -f /var/lib/sorcery/codex 2>/dev/null
# first unmount already mounted filesystems 
for mounted_part in `mount | awk ' { print $3}' | grep /mnt/root | sort -r`
do umount -f $mounted_part 2>/dev/null
done

# then when unmounted, stop raid arrays
for RDEV in `grep raiddev /etc/raidtab | awk '{print $2}'`;
do raidstop $RDEV
done

# now remove raid temporary files so the restart works on all partitions
rm -f /tmp/raid*
rm -f /etc/raidtab
# and the installer-debug log if it exists
rm -f /tmp/installer-debug
swapoff -a

# reset these to the defaults
       export CONFIRM=on
       export GUIDE=on
       ICOMMAND="B"

}

#toggles the debug switch
# SECTION: MISC
toggle_debug() {

  if [ "${DEBUG}" = "yes" ]; then
	DEBUG="no"
  else
	DEBUG="yes"
  fi

  echo "DEBUG=${DEBUG}"
  press_enter

}

#display's the actual installer menu
# TODO: should handle flow and such
#SECTION: INSTALLER
install_menu()  {

 ICOMMAND="B"

 while

     TITLE="Install Menu - for $ARCH architecture"
    A_HELP="Read about the advantages of using Source Mage GNU/Linux"
    B_HELP="Select default language, keymap, and console fonts"
    if [ "$ARCH" = "ppc" ]
	then
	C_HELP="Use mac-fdisk to prepare hard drive partitions"
	else
	C_HELP="Use fdisk, cfdisk or parted to prepare hard drive partitions"
    fi
    D_HELP="Mount and initialize file systems and swap partitions"
    E_HELP="Optionally make software RAID device from existing partitions or discs"
    F_HELP="SMGL recommends 1GB of RAM + SWAP (swap partition or swap file)"
    G_HELP="Select timezone for translating GMT into local time"
    H_HELP="Select architecture and optimizations"
    I_HELP="Copy the distro from CDROM to fixed disk"
    J_HELP="Oops-a-daisy, I forgot I need special drivers... :-)"
    K_HELP="Configure and install the Linux Kernel or copy the default from the ISO"
    L_HELP="Select the daemon for system logging"
    if [ "$ARCH" = "ppc" ] 
	then
	M_HELP="Edit $TARGET/etc/yaboot.conf and run ybin"
	else
	M_HELP="Choose a bootloader and edit it's config"
    fi
    N_HELP="Configure PPP or Ethernet TCP/IP networking"
    O_HELP="Select from a list of spells to optionally install."
    Q_HELP="When ready you may transfer Source Mage from CD to
fixed disk."

    S_HELP="Shell out for a moment"
    P_HELP="Enable or disable guided menu"
    T_HELP="Enable or disable asking of confirmation questions"
    U_HELP="Select which of the installed services should start at boot."
    IG_HELP="Read an Installation Guide"
    R_HELP="Reset all variables and restart Installation"
    V_HELP="Guided menu disabled. Nothing will prevent you from
choosing options in a nonsensical sequence. Good Luck."

    W_HELP="Abort now if you have not made backups. Source Mage
GNU/Linux comes with absolutely no warranty. Run this
script only when booted from the Source Mage
CD. Proceed at your own risk."

    X_HELP="Exit to a manual installation or reboot"
    Y_HELP="Select timezone, architecture optimizations, choose
kernel, syslogger, bootloader and network interfaces.
Then select the optional spells for installation."

    Z_HELP="Turn on debug, to test installer without performing any
           volatile commands"

    if    [  -z  "$GUIDE"  ];  then
#full unguided menu
      ICOMMAND=`"${DIALOG[@]}"  --title  "$TITLE"                         \
                         --nocancel                                \
                         --default-item  $ICOMMAND                 \
                         --item-help                               \
                         --menu "$V_HELP"                          \
                         8 60 0                                  \
                         "A"  "Introduction"            "$A_HELP"  \
                         "B"  "Native Language Support" "$B_HELP"  \
                         "C"  "Partition Drive"         "$C_HELP"  \
                         "E"  "[Optionally] Make RAID device" "$E_HELP" \
                         "D"  "Mount Filesystems and swap" "$D_HELP"  \
                         "F"  "[Optionally] Make Swapfile" "$F_HELP"  \
                         "G"  "Select Timezone"         "$G_HELP"  \
                         "H"  "Architecture Optimize"   "$H_HELP"  \
                         "K"  "Install/Configure Linux Kernel"  "$K_HELP"  \
                         "L"  "Configure Log System"    "$L_HELP"  \
                         "M"  "Configure Bootloader"    "$M_HELP"  \
                         "N"  "Configure Networking"    "$N_HELP"  \
                         "O"  "Select optional spells to install" "$O_HELP" \
                         "I"  "Install Source Mage GNU/Linux"    "$I_HELP"  \
                         "U"  "Choose services to run at boot" "$U_HELP" \
                         "X"  "Done"                    "$X_HELP"  \
                         "S"  "Shell"                   "$S_HELP"  \
                         "P"  "Enable Guided Menu"      "$P_HELP"  \
                         "T"  "Toggle Confirm"          "$T_HELP"  \
                         "R"  "Restart Installation"    "$R_HELP"  \
                         "Z"  "Toggle debug"            "$Z_HELP"  \
                         "?"  "Installation help notes" "$IG_HELP"`


    elif  [  -z  "$ROOT"  ];  then
#initial guided menu
      ICOMMAND=`"${DIALOG[@]}"  --title  "$TITLE"                         \
                         --trim --nocancel                                \
                         --default-item  $ICOMMAND                 \
                         --item-help                               \
                         --menu "$W_HELP"                          \
                         10 60 0                                  \
                         "A"  "Introduction"            "$A_HELP"  \
                         "?"  "Installation Help"       "$IG_HELP" \
                         "R"  "Restart Installation"    "$R_HELP"  \
                         "B"  "Native Language Support" "$B_HELP"  \
                         "C"  "Partition Drive"         "$C_HELP"  \
                         "E"  "[Optionally] Make RAID device" "$E_HELP" \
                         "D"  "Mount Filesystems and swap" "$D_HELP"  \
                         "X"  "Done"                    "$X_HELP"  \
                         "S"  "Shell"                   "$S_HELP"  \
                         "P"  "Disable Guided Menu"     "$P_HELP"`

    elif  [  -z  "$DONE_CONFIG"  ];  then
#this menu presented after root has been selected and mounted
      ICOMMAND=`"${DIALOG[@]}"  --title "$TITLE"                          \
                         --nocancel                                \
                         --default-item  $ICOMMAND                 \
                         --item-help                               \
                         --menu "$Y_HELP"                          \
                         9 60 0                                    \
                         "D"  "Mount Filesystems and swap" "$D_HELP"  \
                         "G"  "Select Timezone"         "$G_HELP"  \
                         "H"  "Architecture Optimize"   "$H_HELP"  \
                         "K"  "Install/Configure Linux Kernel" "$K_HELP"  \
                         "L"  "Configure Log System"    "$L_HELP"  \
                         "M"  "Configure Bootloader"    "$M_HELP"  \
                         "N"  "Configure Networking"    "$N_HELP"  \
                         "O"  "Select optional spells to install" "$O_HELP" \
                         "X"  "Done"                    "$X_HELP"  \
                         "S"  "Shell"                   "$S_HELP"  \
                         "R"  "Restart Installation"    "$R_HELP"  \
                         "?"  "Installation Help"       "$IG_HELP" \
                         "P"  "Disable Guided Menu"     "$P_HELP"`

    else
# final stage
      ICOMMAND=`"${DIALOG[@]}"  --title "$TITLE"                       \
                         --nocancel                                    \
                         --default-item  $ICOMMAND                     \
                         --item-help                                   \
                         --menu "$Q_HELP"                              \
                         8 60 0                                        \
                         "I" "Install Source Mage GNU/Linux to disk "   "$I_HELP"   \
                         "J" "Oops, I really need to compile a kernel " "$J_HELP" \
                         "M" "Reconfigure ${BOOTLOADER}" "$M_HELP"                \
                         "U" "Choose services to run at boot" "$U_HELP" \
                         "X" "Done"                        "$X_HELP"  \
                         "S" "Shell"                       "$S_HELP"  \
                         "R" "Restart Installation"        "$R_HELP"  \
                         "?" "Installation Help"           "$IG_HELP" \
                         "P" "Disable Guided Menu"         "$P_HELP"`

    fi

  do

    case  $ICOMMAND in
      A)  introduction     ;;
      B)  nls              ;;
      C)  fdisc            ;;
      D)  mounty           ;;
      E)  mk_raid_device   ;;
      F)  mk_swap_file     ;;
      G)  timezone         ;;
      H)  optimize_architecture ;;
      J)  compile_kernel   ;;
      K)  make_kernel      ;;
      L)  syslog           ;;
      M)  config_bootloader ;;
      N)  network          ;;
      O)  spell_select     ;;
      I)  install_to_target ;;
      U)  service_select   ;;
      X)  goodbye          ;;
      S)  shell            ;;
      P)  toggle_guide     ;;
      T)  toggle_confirm   ;;
      R)  restart_install  ;;
      Z)  toggle_debug     ;;
      ?)  install_help     ;;
    esac

  done

}

# sets up the system for the install process
# SECTION: INSTALLER
main()  {

  export  PATH="/bin:/usr/bin:/sbin:/usr/sbin"

# mount /proc (needed later for /proc/partitions for instance

  mount -t proc proc /proc

# mount /dev (is it needed)
# mount -t devfs devfs /dev

        ARCH=`uname -m`

# TARGET is the mount point where Source Mage will be installed it
# should be defined before running this script or it will default to
# /mnt/root. Since this script is intended to run from a CDROM (ie
# read-only filesystem), the directory must already exists.

        TARGET=${TARGET:=/mnt/root}
       CONFIRM=on
         GUIDE=on

# check for TARGET
  if [ ! -d "${TARGET}" ]; then
    echo "TARGET=${TARGET} is not an existing directory."
	exit 1
  fi

    install_menu

}  

#
# this script really starts here
#

# notes on dialog:
# General warning about dialog --radiolist. Since the result is
# enclosed with spurious ". 
# For instance:
#
# dialog --stdout --radiolist radiolist 9 60 2 \
#	"grub" "grub text" "on" \
#	"lilo" "lilo text" "off"
#
# will return "grub" instead of grub.
# We will use sed -e 's/^"//' -e 's/"$//' to remove spurious "".
#
# dialog --yesno     : add 4 to get height
# dialog --msgbox    : add 5 to get height
# dialog --menu      : add 6 to get height (let menu-height to always be 0)
# dialog --radiolist : add 6 to get height (let list-height to always be 0)
# dialog --checklist : add 6 to get height (let list-height to always be 0)
# dialog --inputbox  : add 7 to get height

# do some initial config things
# TODO: add these to a function
if [ -f /etc/installerdata/version ]; then
  . /etc/installerdata/version 
else
  VERSION=`date +%Y%m%d`-debug
fi

ARCH_SPECS=/var/lib/sorcery/archspecs

DIALOG=( "dialog" "--backtitle" \
         "Source Mage GNU/Linux Installer v. ${VERSION}" \
	     "--stdout" "--trim")

trap  ":"  INT QUIT

# start the installation process
main
