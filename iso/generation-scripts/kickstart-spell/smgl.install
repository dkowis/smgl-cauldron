#!/bin/sh
########################################################################
# Copyright 2004 by Hamish Greig <hgreig@bigpond.net.au>               #
# Copyright 2004 by Kevin Dahan <unet@sourcemage.org>                  #
# Copyright 2003 by Laurent Wandrebeck <low@sourcemage.org>            #
# Copyright 2003 by Benoit Papillault <benoit.papillault@free.fr>      #
# Copyright 2003 by Seth Woolley <seth@tautology.org>                  #
# Copyright 2002 by Source Magers                                      #
# Copyright 2001 by Kyle Sallee                                        #
########################################################################
#                                                                      #
# This program is free software; you can redistribute it and/or modify #
# it under the terms of the GNU General Public License as published by #
# the Free Software Foundation; either version 2 of the License, or    #
# (at your option) any later version.                                  #
#                                                                      #
#   This program is distributed in the hope that it will be useful,    #
#   but WITHOUT ANY WARRANTY; without even the implied warranty of     #
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the      #
#   GNU General Public License for more details.                       #
#                                                                      #
#  You should have received a copy of the GNU General Public License   #
#  along with this program; if not, write to the Free Software         #
#  Foundation, Inc., 59 Temple Place, Suite 330, Boston,               #
#  MA  02111-1307  USA                                                 #
#                                                                      #
########################################################################
#         This is a menu driven process of                             #
#  installing from the Source Mage GNU/Linux ISO                       #
#                                                                      #
#  It currently relies on some files in /etc/installerdata/*, the      #
#  files are available in the same place you got this script. If not,  #
#  then contact the supplier of this script.                           #
#                                                                      #
#  1) /etc/installerdata/install.guide                                 #
#         a text file describing the installation process and          #
#         explaining the options available.                            #
#  2) /etc/installerdata/install-list                                  #
#         a list of the minimum required spells to be able to start    #
#         casting or a rebuild.                                        #
#  3) /etc/installerdata/optional-list                                 #
#         a list of useful spells that are optionally offered for      #
#         install.                                                     #
#  4) /etc/installerdata/kernel.help                                   #
#         a help file suggesting options needed by the SMGL system     #
#  5) /etc/installerdata/raidlevel                                     #
#         a text file listing the raid levels and simple explanations  #
#         of them.                                                     #
#  6) /etc/installerdata/fstab                                         #
#         a listing of virtual filesystems for the installer to add    #
#         the physical systems entries to.                             #
#                                                                      #
########################################################################

introduction()  {
# Doh!
  $DIALOG  --title  "Welcome to Source Mage GNU/Linux"  \
           --msgbox                                     \
"The purpose of Source Mage GNU/Linux is to return control to System Administrators that the wizards and maintainers of modern distributions have steadily chipped away." 8 65

  $DIALOG  --cr-wrap                                         \
           --title  "The Benefits of Source Mage GNU/Linux"  \
           --msgbox                                          \
"Source Mage GNU/Linux empowers 
System Administrators to choose:

 the architecture that programs are compiled for,
 the dependencies a program is compiled with,
 compiler optimizations, and compile time options.

And it provides the conveniences of:

 command line and menu driven package management,
 ASCII configuration and data files,
 FHS 2.2 compliant filesystem hierarchy,
 parallel simpleinit and networking." 18 65

}


inputbox()  {

  $DIALOG  --nocancel                     \
           --inputbox                     \
           "$1"  0 0  "$2"

}


chroot_cmd() {
    # only chroot if it is a valid install
    if [ -z "$DEBUG" ]; then
    mount --bind /dev ${TARGET}/dev
    mount --bind /proc ${TARGET}/proc
    mount --bind /var/cache/sorcery ${TARGET}/var/cache/sorcery
    if [ -z $SWAPON ]; then chroot "${TARGET}" swapon -a ; fi
    chroot "${TARGET}" "$@"
    if [ -z $SWAPON ]; then chroot "${TARGET}" swapoff -a ; fi
    umount ${TARGET}/dev
    umount ${TARGET}/proc
    umount ${TARGET}/var/cache/sorcery
   else echo "Runnning chroot "${TARGET}" "$@"" >> /tmp/installer-debug
    fi
}


confirm()  {

  if  [  -z  "$CONFIRM"  ];  then

    if  [  -n  "$2"  ];  then  false
                         else  true
    fi

  else
    $DIALOG $2 --yesno  "$1"  8 50
  fi

}


goodbye() {

    # copy the install-debug log 
    if [ -d ${TARGET}/var/log ] && [ -s /tmp/installer-debug ]
    then cp -f /tmp/installer-debug ${TARGET}/var/log/SMGL-$VERSION-install.log
    fi

    PROMPT="Reboot now?" 
    if  confirm  "$PROMPT" --defaultno ;  then
        exec shutdown -r -q now
    else
        exit  0
    fi
}


list_discs()  {
  # sfdisk reads /proc/partitions for discs so it is the same as cat /proc/partitions but better output
  DISK_LIST=`sfdisk -s | grep /dev | cut -d: -f1 | sed -e 's/ //g'`
  for  DISK in $DISK_LIST;
  do if ! sfdisk -qg $DISK | grep -q "cannot get geometry" # a cdrom has no geometry allowing us to remove it from the list
     then echo  $DISK
          echo  "Size `sfdisk -sq $DISK` "
     fi
  done

}


list_parts()  {
  # grepping a non-existant file gives an error
  touch /etc/raidtab
  for PARTITION in `cat /proc/partitions |awk '$3 !~ /^1$/ {print $4}' | grep -v ram | grep -v disc | grep -v name | sort |sed -e 's/ //g'`;
  do if ! sfdisk -s | grep -q /dev/$PARTITION\: && !  echo  $FS_LIST | grep -q $PARTITION\  && ! `grep device /etc/raidtab | grep -q $PARTITION\ `
         then echo  /dev/$PARTITION
           if [[ `uname -r` == 2.6.* ]] 
           then if [[ $PARTITION == md* ]]
                then echo  "Size `sfdisk -sq /dev/$PARTITION` Type RAID array " || echo "size and type unknown"
                else echo  "Size `sfdisk -sq /dev/$PARTITION` Type `sfdisk -lq | grep $PARTITION\ | awk '{print $(NF-1) " " $NF}' | sed -e s/[0123456789].[\ ]//g` " || echo "size and type unknown"
                fi
            # 2.4.25 wrongly tries to list removable media (cdroms, etc) which have no geometry
            # so to avoid a lot of errors, I modified the check, but some weird 
            # mojo wouldn't let the "backticks within backticks" work so I used both ` ` and $()
           else if [[ $PARTITION == md* ]]
                then echo  "Size `sfdisk -sq /dev/$PARTITION` Type RAID array " || echo "size and type unknown"
                else echo  "Size `sfdisk -sq /dev/$PARTITION` Type `sfdisk -lq $(echo /dev/$PARTITION | sed -e s/part[0123456789]*/disc/) | grep $PARTITION\  | awk '{print $(NF-1) " " $NF}' | sed -e s/[0123456789].[\ ]//g` " || echo "size and type unknown"
                fi
           fi
     fi
  done

}

# the raid functions use of --checklist means the regular list_parts wouldn't work.
list_raid_parts()  {
  # grepping a non-existant file gives an error
  touch /etc/raidtab
  for PARTITION in `cat /proc/partitions |awk '$3 !~ /^1$/ {print $4}' | grep -v ram | grep -v disc | sort | grep -v name | sed -e 's/ //g'`;
  do
    if ! `sfdisk -s | grep -q /dev/$PARTITION\:` && ! echo $FS_LIST | grep -q $PARTITION\  && ! `grep device /etc/raidtab | grep -q $PARTITION\ `
    then echo  /dev/$PARTITION
         if [[ `uname -r` == 2.6.* ]] 
         then if [[ $PARTITION == md* ]]
              then echo  "Size `sfdisk -sq /dev/$PARTITION` Type RAID array " || echo "size and type unknown"
              else echo  "Size `sfdisk -sq /dev/$PARTITION` Type `sfdisk -lq | grep $PARTITION\  | awk '{print $(NF-1) " " $NF}' | sed -e s/[0123456789].[\ ]//g` " || echo "size and type unknown"
              fi
           # 2.4.25 wrongly tries to list removable media (cdroms, etc) which have no geometry
           # so to avoid a lot of errors, I modified the check, but some weird 
           # mojo wouldn't let the "backticks within backticks" work so I used both ` ` and $()
         else if [[ $PARTITION == md* ]]
              then echo  "Size `sfdisk -sq /dev/$PARTITION` Type RAID array " || echo "size and type unknown"
              else echo  "Size `sfdisk -sq /dev/$PARTITION` Type `sfdisk -lq $(echo /dev/$PARTITION | sed -e s/part[0123456789]*/disc/) | grep $PARTITION\  | awk '{print $(NF-1) " " $NF}' | sed -e s/[0123456789].[\ ]//g` " || echo "size and type unknown"
              fi
         fi
         echo  off
    fi
  done

}

get_part()  {

  TITLE="Partition Selection Menu"
   HELP="Please select a partition. \
Sizes are in blocks\n\
Use cancel or esc to leave this menu"

  $DIALOG  --title     "$TITLE"  \
           --menu      "$HELP"   \
           0 0 0                 \
          `list_parts`

}


choose_raid_parts()  {
  TITLE="Installer menu for RAID device generation"
   HELP="Please select partitions to make the RAID array. \
Sizes are in blocks\n\
Use cancel or esc to leave this menu\n\
Lilo and grub can only boot from a RAID 1 array, \n\
You can return to the previous menu and repartition so you have a separate /boot partition."

  $DIALOG  --title     "$TITLE"     \
           --separate-output        \
           --checklist "$HELP"      \
           0 0 0                    \
          `list_raid_parts`
}

choose_raid_level()  {

  TITLE="RAID level selection Menu"
   HELP="Please select RAID level. \
For more detailed descriptions of RAID levels read the SMGL Install Guide \n\
Use cancel or esc to leave this menu"

  $DIALOG  --title     "$TITLE"     \
           --item-help              \
           --menu      "$HELP"      \
           0 0 0                    \
	`cat /etc/installerdata/raidlevel`

}


get_disc()  {

  TITLE="Disk Selection Menu"
   HELP="Please select a disk \n\
Sizes are listed in blocks\n\
Use cancel or esc to leave this menu"



  $DIALOG  --title     "$TITLE"  \
           --menu      "$HELP"   \
           0 0 0                 \
          `list_discs`

}


get_filesystem()  {

   TITLE="Filesystem Selection Menu"
    HELP="Please select a filesystem"
    EXT2="Second Extended file system "
    EXT3="Second Extended journaling file system "
     XFS="XFS journaling file system "
  REISER="Reiserfs journaling file system "
     JFS="JFS journaling file system "
    SWAP="Swap Partition"

  $DIALOG  --title     "$TITLE"   \
           --menu      "$HELP"    \
           0 0 0                  \
           "ext2"      "$EXT2"    \
           "ext3"      "$EXT3"    \
           "reiserfs"  "$REISER"  \
           "swap"      "$SWAP"    \
           "xfs"       "$XFS"	  \
           "jfs"       "$JFS"

}


show_keymaps()  {

  KEYDIR="/usr/share/keymaps/i386"

  azerty="`ls  $KEYDIR/azerty`"
  dvorak="`ls  $KEYDIR/dvorak`"
  fgGIod="`ls  $KEYDIR/fgGIod`"
  qwerty="`ls  $KEYDIR/qwerty`"
  qwertz="`ls  $KEYDIR/qwertz`"

  MAP_FILES=`echo  -e  "$azerty\n$dvorak\n$fgGIod\n$qwerty\n$qwertz"  |
             sort  |  sed  "s/\.kmap\.gz//"`

  for  MAP  in  $MAP_FILES;  do
    echo  "${MAP}"
    echo  "keymap "
  done

}


keymap_menu()  {

     TITLE="Keymap Selection Menu"
      HELP="Please select your preferred keymapping."
   KEYMAPS=`show_keymaps`
 
    KEYMAP=`$DIALOG  --title  "$TITLE"  \
                     --menu   "$HELP"   \
                     0 0 0              \
                     $KEYMAPS`          &&
  
  LOADKEYS="loadkeys  $KEYMAP"          &&
  if [ -z "$DEBUG" ]
  then loadkeys  $KEYMAP
  fi
  echo -e "Running $LOADKEYS" >> /tmp/installer-debug
}


fdisc()  {
    if [ "$ARCH" = "ppc" ]
	then
	DISC=`get_disc`                                             &&
	PROMPT="Remember you need to create a bootstrap partition \
        first (type 'b' at the prompt). " &&
	if  confirm  "$PROMPT";  then
	  if [ -z "$DEBUG" ];
	  then /sbin/mac-fdisk  $DISC
	  else echo "Running /sbin/mac-fdisk on $DISC" >> /tmp/installer-debug
	  fi
	fi
	else
	CFDISK="Curses based disk partition table manipulator"  
	FDISK="Partition table manipulator"
	PARTED="Create, destroy, resize, and copy partitions"
	HELP="Please create at least a root partition. \n\
	A boot partition is recommended, for RAID and some filesystems it is mandatory. \n\
	Lilo can only boot from a RAID 1 array and xfs or reiserfs formatting can cause problems with the MBR.
	Grub can boot from any filesystem, but still can't boot from RAID unless it is RAID 1 or has a separate boot partition"
	TITLE="Partitioning Menu"
	# cheat again -> '
	DISC=`get_disc`                                             &&
	PROG=`$DIALOG  --title   "$TITLE"                           \
                    --menu    "$HELP"                            \
                    0 0 0                                        \
                    "cfdisk"  "$CFDISK"                          \
                    "fdisk"   "$FDISK"                           \
                    "parted"  "$PARTED"`                         &&
	
	PROMPT="Are you certain that you want to run $PROG on $DISC"  &&
	
	if  confirm  "$PROMPT";
	then if [ -z "$DEBUG" ];
	     then $PROG  $DISC
	     fi
	     echo "Running $PROG on $DISC" >> /tmp/installer-debug	
	fi
    fi
}

# function to provide correct name for the filesystem-formatting binary (eg. mk??fs)
get_mk_prog()  {

  case  $1  in
    reiserfs)  echo  "mkreiserfs"  ;;
        swap)  echo  "mkswap"      ;;
        ext2)  echo  "mkfs"        ;;
        ext3)  echo  "mkfs"        ;;
         xfs)  echo  "mkfs"        ;;
         jfs)  echo  "mkfs"        ;;
  esac

}


check_partition()  {

  PROMPT="Check for errors?"

  case  $1  in  
    ext2|ext3|jfs|swap)  if   confirm  "$PROMPT"  "--defaultno";  then
                       echo  "-c";  
                     fi    ;;
                 *)  true  ;;
  esac

}

# filesystems using mkfs need switches passed
get_fstype()  {

  case  $1  in
    ext2)  echo  "-text2"  ;;
    ext3)  echo  "-text2"  ;;
     xfs)  echo  "-txfs"   ;;
     jfs)  echo  "-tjfs"   ;;
       *)  true            ;;
  esac

}


use_the_force()  {

  case  $1  in
    ext3)  echo  "-j"  ;;
     xfs)  echo  "-f"  ;;
       *)  true        ;;
  esac

}


mk_swap_file()  {

  LOCATION_PROMPT="Please enter the location for the swapfile."
      SIZE_PROMPT="Source Mage GNU/Linux recommends 1GB of RAM + SWAP. \n\
      Please enter the number of megabytes to use for this swapfile."
          SUCCESS="Swapfile created."
          FAILURE="Problem creating swapfile."
             ZERO="/dev/zero"

    DEVICE=`inputbox  "$LOCATION_PROMPT"  "/.swapfile"`    &&
  SWAPFILE="$TARGET$DEVICE"                               &&
      SIZE=`inputbox  "$SIZE_PROMPT"      "1024"`         &&
    PROMPT="Make swapfile $SWAPFILE of $SIZE megabytes?"  &&

  if  confirm  "$PROMPT"
  then if  dd  of=$SWAPFILE  if=$ZERO bs=1M count=$SIZE  &&
           mkswap      $SWAPFILE                         &&
           chmod  000  $SWAPFILE
       then DP="$DEVICE	none"
            FOL="swap	defaults	0 0"
            FSTAB_ENTRY="$DP	$FOL"
            FS_LIST=`echo  -e  "$FSTAB_ENTRY\n$FS_LIST"`
            $DIALOG  --msgbox  "$SUCCESS"  8 50
       else sleep  10
            $DIALOG  --msgbox  "$FAILURE"  8 50
            return 1
       fi
  fi
}


make_fsys()  {

  SUCCESS="Filesystem created"
  FAILURE="Filesystem creation failed"
  
     PROG=`get_mk_prog  $FSYS`
     if [ -n "$DEBUG" ]
     then REAL_PROG=$PROG &&
          PROG=true
     fi
  COMMAND="Would you like to initialize ${DEVICE}
using the following command (if you answer NO, then
${DEVICE} \nwill just be mounted asis, unformatted):
\n$PROG $FSTYPE $CHECK $FORCE $DEVICE"

  if  $DIALOG  --nocancel  --yesno  "$COMMAND"  11 80
  then if  $PROG $FSTYPE $CHECK $FORCE $DEVICE
       then $DIALOG  --msgbox  "$SUCCESS"  8  50
       else sleep  10 
            $DIALOG  --msgbox  "$FAILURE"  8  50
         return 1
       fi
       echo -e "$DEVICE formatted as $FSYS with $PROG $FSTYPE $CHECK $FORCE $DEVICE and mounted" >> /tmp/installer-debug
  fi
}


mount_fsys()  {

    MOUNT=$TARGET$MNT_POINT
  SUCCESS="Mounted $DEVICE on $MOUNT"
  FAILURE="Failed mounting $DEVICE on $MOUNT"
  if [ -n "$DEBUG" ]
  then mount_command=true
  else mount_command=mount
  fi
  case  $FSYS  in
    ext2|ext3|reiserfs|xfs|jfs)
      if  mkdir -p $MOUNT && $mount_command -t $FSYS -o $OPTIONS $DEVICE $MOUNT
      then
        case  $MNT_POINT  in
              /)  ROOT=$DEVICE  ;;
          /boot)  BOOT=$DEVICE  ;;
        esac
        $DIALOG  --msgbox  "$SUCCESS"  8 50
      else
        sleep  10
        $DIALOG  --msgbox  "$FAILURE"  8 50
        return 1
      fi
    ;;
    swap)  PROMPT="Mount swap partition (or swapfile) now so it is usable during install ? (Recommended)"
                if confirm $PROMPT
                then [ -z "$DEBUG" ] && swapon $PART && export SWAPON=on
                else true
                fi
    ;;
  esac

}


make_fstab_line()  {

         DP="$DEVICE	$MNT_POINT"    &&
        FOL="$FSYS	$OPTIONS"  &&
FSTAB_ENTRY="$DP	$FOL	$LAST"     &&
    FS_LIST=`echo  -e  "$FS_LIST\n$FSTAB_ENTRY"`

}


determine_fstab_settings()  {

  LAST="0 2"
  case  $FSYS  in
        swap)  OPTIONS="defaults"                 ;;
    reiserfs)  OPTIONS="defaults,notail,noatime"  ;;
        ext3)  OPTIONS="defaults,noatime"         ;;
         xfs)  OPTIONS="defaults,noatime"         ;;
         jfs)  OPTIONS="defaults,noatime"         ;;
        ext2)  OPTIONS="defaults,noatime"         ;;
  esac
  case $MNT_POINT in
    /)  LAST="0 1"  ;;
    *)  LAST="0 2"  ;;
  esac

}


get_mount_point()  {

  PROMPT="Please enter a mount point"

  if    [  -z  "$ROOT"  ];  then

    MNT_POINT="/"
    [  "$FSYS"  !=  "swap"  ]

  elif  [  "$FSYS"  ==  "swap"  ];  then

    MNT_POINT="none"

  else

    MNT_POINT=`inputbox  "$PROMPT"  "/"`  &&
    [  -n  "$MNT_POINT"  ]                &&
    [  "$MNT_POINT"  !=  "/"  ]  

  fi

}


mount_partition()  {

      PART=`get_part`                  &&
      FSYS=`get_filesystem`            &&
     CHECK=`check_partition  $FSYS`    &&
     FORCE=`use_the_force    $FSYS`    &&
    FSTYPE=`get_fstype       $FSYS`    &&
    DEVICE=$PART                       &&

  get_mount_point                      &&
  determine_fstab_settings             &&
  make_fsys                            &&
  mount_fsys                           &&
  make_fstab_line                      
  
}


mounty()  {

      PROMPT="Are you done making partitions?"
  ROOT_FIRST="The root partition must be mounted first"

  if    [  -n  "$ROOT"  ];   then
    mount_partition
  elif  confirm  "$PROMPT";  then
    $DIALOG  --msgbox  "$ROOT_FIRST"  8 40
    mount_partition
  fi

}


mk_raid_device() {
   mk_raid_config 
   PROMPT="Edit the raidtab before initialising the arrays ?\nExperienced users might like to change RAID 5 parity-algorithm options \
or even change a disk to be spare within the array"
 if [ -s /etc/raidtab ]; then
   if confirm $PROMPT --defaultno
   then $EDITOR /etc/raidtab
   fi
 fi                                        
   PROMPT="Make and start the RAID arrays now ?\nCancel or Esc returns to install menu without changing \
the partition tables and initialising array"
 if [ -s /etc/raidtab ] ; then 
   if confirm $PROMPT --defaultno ; then
   # read which partitions are to be in the array
   RD_PARTS="`grep device /etc/raidtab |awk '{print $2}'`" 
   # this ugly thing finds which discs the partitions belong to, and converts the partition type to raid auto-detect
   # tr is used as our IFS runs space separated vars together
   if [[ `uname -r` == 2.4.* ]]
   then RD_DISC="`echo $RD_PARTS | sed s/part[0123456789]*/disc/g | tr ' ' '\n' | sort | uniq`"  
   else RD_DISC="`echo $RD_PARTS | sed s/[0123456789]*//g | tr ' ' '\n' | sort | uniq`"
   fi
   for ind_disk in `echo $RD_DISC | tr ' ' '\n'`
   do if [[ `uname -r` == 2.6.* ]]; 
      then sfdisk -d  $ind_disk > /tmp/`echo $ind_disk | sed 's:/dev/::'`.table
           for part in `echo $RD_PARTS | tr ' ' '\n'`
           do if grep -q $part /tmp/`echo $ind_disk | sed 's:/dev/::'`.table
              then sed -i -e "/`echo $part | tr '/' ' ' | awk '{print $NF}'`/s:Id=..:Id=fd:g" /tmp/`echo $ind_disk | sed 's:/dev/::'`.table
              fi
           done
           if [ -z "$DEBUG" ]
           then sfdisk -f -q $ind_disk < /tmp/`echo $ind_disk | sed 's:/dev/::'`.table
           fi
       else sfdisk -d  $ind_disk > /tmp/disk.table
           for part in `echo $RD_PARTS | tr ' ' '\n'`
           do if grep -q $part /tmp/disk.table
              then sed -i -e "/`echo $part | tr '/' ' ' | awk '{print $NF}'`/s:Id=..:Id=fd:g" /tmp/disk.table
              fi
           done
           if [ -z "$DEBUG" ]
           then sfdisk -f -q $ind_disk < /tmp/disk.table
           fi
      fi
   done

   # now make the arrays and start them
   for RDEV in `grep raiddev /etc/raidtab | awk '{print $2}'`
   do if [ -z "$DEBUG" ]
      then mkraid -R $RDEV
      fi
   echo "making and initialising $RDEV" >> /tmp/installer-debug
   done
   else return 1
   fi
 fi

}

mk_raid_config() {

#detect an already initialised array and set the counter
if [ -z $PLACE ]
then if grep -q md /proc/partitions
     then for i in `cat /proc/partitions | grep md | awk '{print $4}'| sort`; 
          do if  [ -h /dev/$i ]; 
             then PLACE=`echo $i | cut -c 3`
             else PLACE=`echo $i | cut -d/ -f2`
             fi 
          done
     else PLACE=-1
     fi
fi
((PLACE++))
# choose which partitions to turn into an array
RAID_PARTS=`choose_raid_parts`                   &&
# tr is used as our IFS runs space separated vars together
echo $RAID_PARTS | tr ' ' '\n' > /tmp/raid.parts &&
NR_DISCS=`cat /tmp/raid.parts | wc -l`           &&
# choose raid-level
RAIDLEVEL=`choose_raid_level`                    &&
#write the raidtab
echo "raiddev /dev/md$PLACE" >> /etc/raidtab     &&
echo "raid-level $RAIDLEVEL"   >> /etc/raidtab   &&
echo "nr-raid-disks $NR_DISCS" >> /etc/raidtab   &&
if [ "$RAIDLEVEL" = "5" ] || [ "$RAIDLEVEL" = "4" ] 
then echo "parity-algorithm left-symmetric" >> /etc/raidtab    
fi                                               &&
echo "persistent-superblock 1" >> /etc/raidtab   &&
echo -e "chunk-size 32 \n" >> /etc/raidtab       &&
i=0                                              && 
for line in `< /tmp/raid.parts`; do echo -e "\tdevice $line\n\traid-disk $i";((i++));done >> /etc/raidtab &&
echo " " >> /etc/raidtab                         
PROMPT="Finished making RAID devices ?"
if ! confirm $PROMPT; then
   mk_raid_config
fi

}

make_fstab()  {
  cp -f /etc/installerdata/fstab ${TARGET}/etc/fstab &&
  if [[ `uname -r` == 2.6.* ]]
  then FLOPPY=fd0
       CDROM=`cat /proc/mounts | grep iso9660 | awk '{print $1}'`
       sed -i -e 's/\#sysfs/sysfs/' ${TARGET}/etc/fstab && mkdir ${TARGET}/sys
  else CDROM=/dev/cdroms/cdrom0
       FLOPPY=floppy/0
  fi 
  echo  -e  "$FS_LIST"  >>  "${TARGET}/etc/fstab"


  echo -e "$CDROM  /mnt/cdrom   auto  defaults,noauto,user  0 0" >> "${TARGET}/etc/fstab"
  echo -e "/dev/$FLOPPY       /mnt/floppy  auto  defaults,noauto,user  0 0" >> "${TARGET}/etc/fstab"
  
}

# 10/09/2003 The code for optimize_architecture(), architecture_menu() and
# optimization_menu() has been adapted from /usr/sbin/sorcery version 1.3 (Benoit PAPILLAULT)

optimize_architecture() {

    architecture_menu  ARCHITECTURE  "Build system selection"    &&
    if [[ $CROSS_INSTALL == on ]]; then
        architecture_menu  TARGET      "Target system selection"
    fi                                                           &&
    optimization_menu                                            &&

# next stop kernel config
[ -n "$GUIDE" ] && ICOMMAND="K"

}


architecture_menu() {

    local  SPECFILE
    local  LIST
    local  IDX=0
    alias use_gcc2=false

    for  SPECFILE  in  `find  ${ARCH_SPECS} -not  -name '*~' | sort`;
      do
      if  [[  -x  $SPECFILE  ]]  && grep  -q  "CPUNAME"  $SPECFILE
      then
          local CPUNAME=""
          CPUNAME=$( .  $SPECFILE  &&  echo $CPUNAME )  &&
          LIST[$((IDX++))]=`basename "${SPECFILE}"`
          LIST[$((IDX++))]=${CPUNAME}
          LIST[$((IDX++))]=${CPUNAME}
      fi
    done
    
    local ARCH_TITLE="$2"
    local ARCH_HELP="Please select a microprocessor category"

    ARCHITECTURE=`$DIALOG --title  "$ARCH_TITLE"     \
                               --item-help                \
                               --no-cancel                \
                               --menu                     \
                               "$ARCH_HELP"               \
                               0 0 0                      \
                               "${LIST[@]}"`              &&

        echo -e ARCHITECTURE=\"$ARCHITECTURE\" >>${TARGET}/etc/sorcery/local/config 

}


optimization_menu() {
    # default flags
    SPEEDY=on
    COMBRELOC=on
    STRIP=on

    local OPTIMIZATIONS
    local      OPT_TITLE="Optimization Menu"
    local       OPT_HELP="Please select optimizations"
    
    local    SPEEDY_HELP="Optimize to increase performance of generated code (safe)"
    local     RISKY_HELP="Optimize to increase performance ... by violating ANSI or IEEE rules"
    local      TINY_HELP="Optimize to decrease size of generated code (safe)"
    local     STRIP_HELP="Remove all symbol table and relocation (debugging) information"
    local COMBRELOC_HELP="Speeds up loading libs, also needed for prelink (safe)"

  OPTIMIZATIONS=`$DIALOG --title  "$OPT_TITLE"           \
                               --no-cancel               \
                               --item-help               \
                               --separate-output         \
                               --checklist               \
                               "$OPT_HELP"               \
                               0 0 0                     \
  "speedy"    "  +size  ++speed"  "$SPEEDY"    "$SPEEDY_HELP"    \
  "risky"     "          +speed"  "$RISKY"     "$RISKY_HELP"     \
  "combreloc" "         ++speed"  "$COMBRELOC" "$COMBRELOC_HELP" \
  "tiny"      "  -size"           "$TINY"      "$TINY_HELP"      \
  "strip"     " --size"           "$STRIP"     "$STRIP_HELP"`    &&

        OPTIMIZATIONS=`echo  ${OPTIMIZATIONS}  |  tr  '\n'  ' '`                         &&

        echo -e OPTIMIZATIONS=\"$OPTIMIZATIONS\" >> ${TARGET}/etc/sorcery/local/config   &&
    

MAKE_JOBS=`$DIALOG --title "Enter the number jobs for cast to run" --inputbox "\n\
The # of CPUs + 1 is a good way to keep the processor optimised during casts" 0 0 1`     &&

echo MAKE_NJOBS=$MAKE_JOBS > ${TARGET}/etc/sorcery/local/compile_config                  &&

 # if it isn't -x sorcery won't read it
chmod a+x ${TARGET}/etc/sorcery/local/compile_config

}


make_grub_conf()  {

mkdir -p ${TARGET}/boot/grub

BOOT=${BOOT:=$ROOT}

if [ "${BOOT}" != "${ROOT}" ]
then BOOTLOC=""
else BOOTLOC=/boot
fi
export BOOTLOC

cat > ${TARGET}/boot/grub/menu.lst <<EOF

#
# Source Mage installer generated menu.lst
#

# Boot automatically after 30 secs.
timeout 10

# By default, boot the first entry.
default 0

# Fallback to the second entry.
fallback 1

# Splashimage, provides a nice image for the background
splashimage ${BOOTLOC}/grub/images/smgl-splash.xpm.gz

# defines menu foreground/background, highlight foreground/background
color  black/light-gray white/red

title  Source Mage GNU/Linux `uname -r`
kernel ${BOOTLOC}/vmlinubz-`uname -r` root=${ROOT}

EOF

ln -sf menu.lst ${TARGET}/boot/grub/grub.conf

}


make_lilo_conf()  {
 # copy the image file
 cp -f /boot/boot.bmp ${TARGET}/boot/

BOOT=${BOOT:=$ROOT}
if [[ "$BOOT" == /dev/md* ]]
then BOOT=`grep device /etc/raidtab | grep -o /dev/.*$ | head -n 1`
fi
if [[ ${MBR} == YES ]] 
then [[ `uname -r` == 2.6.* ]] && BOOT=`echo ${BOOT} | sed -e 's/[0123456789]*//g'`
     [[ `uname -r` == 2.4.* ]] && BOOT=`echo ${BOOT} | sed -e 's/part[0123456789]*/disc/'`
fi

cat > ${TARGET}/etc/lilo.conf <<EOF
boot=${BOOT}
root=${ROOT}

prompt
# lba32
delay=128
timeout=128
install=boot-bmp.b
bitmap=/boot/boot.bmp
bmp-table=227p,233p,1,7
bmp-colors=13,0,,11,0,13
bmp-timer=76,30,11,0
map=/boot/map

image = /boot/vmlinubz-`uname -r`
    label = linux-`uname -r`
    read-only
EOF

}


make_yaboot_conf()  {

RT_PROMPT="Please enter your / device"
RT=`$DIALOG  --nocancel                     \
                 --inputbox                     \
               "$RT_PROMPT" 10 40 "/dev/discs/disc0/part"`
BD_PROMPT="Please select your bootstrap partition"
BD=`$DIALOG  --nocancel                     \
                 --inputbox                     \
               "$BD_PROMPT" 10 40 "/dev/discs/disc0/part2"`
OFW_PROMPT="Please enter your OF device (e.g. hd:2)"
OFW=`$DIALOG  --nocancel                     \
                 --inputbox                     \
               "$OFW_PROMPT" 10 40 hd:2`

#need to run hformat if the partition is new (aka stupid yaboot)
#won't hurt anyway =)
if [ -z "$DEBUG" ]; then
chroot_cmd /usr/bin/hformat ${BD}
chroot_cmd /usr/sbin/yabootconfig -r ${RT} -b ${BD}
chroot_cmd /usr/sbin/ybin -b ${BD} -o ${OFW} 
echo "You should check your yaboot.conf file (option 'Configure Bootloader')"
sleep 5
fi
echo "configuring yaboot, blablabla" >> /tmp/installer-debug
export RT BD OFW

}

chroot_install() {
# check if it's already installed then install it
    if ! grep -q $*\: $TARGET/var/state/sorcery/packages
    then chroot_cmd tar Pxjpvf /var/cache/sorcery/$*-`gaze version $* | tail -n +3 | head -n 1 | awk '{print $4}'`* 2>> /tmp/installer-debug
         chroot_cmd ldconfig 2>> /tmp/installer-debug
         [ -z "$DEBUG" ] && echo "chroot installing $*" >> /tmp/installer-debug     
         [ -n "$DEBUG" ] && echo "debug-chroot installing $*" >> /tmp/installer-debug     
         echo "$*:`date +%Y%m%d`:installed:`gaze version $* | tail -n +3 | head -n 1 | awk '{print $4}'`" >> ${TARGET}/var/state/sorcery/packages 
    fi

}

chroot_newdep() {
# this is run after the default list is installed so it checks in the list of optional spells waiting before installing
            for newdep in `gaze DEPENDS $(echo $* | cut -d: -f1) | grep ^depends | awk '{print $2}' | sed -e 's/"//g'`
            do if ! `echo $OPTIONALS | grep -q '${newdep} '`
               then chroot_install $newdep
               fi
            done

}

setup_target() {

# install sorcery to ${TARGET}
  CROSS_INSTALL=on INSTALL_ROOT=$TARGET sorcery -v >/dev/null

# hack in case grimoire linux is behind the installer
  echo "Adding KERNEL_VERSION  to ${TARGET}/etc/sorcery/local/depends/linux" >> /tmp/installer-debug
  echo "KERNEL_VERSION=`uname -r`"  >> ${TARGET}/etc/sorcery/local/depends/linux
   
  echo "Adding sources to ${TARGET}/var/spool/sorcery" >> /tmp/installer-debug
  cp -f /var/spool/sorcery/* ${TARGET}/var/spool/sorcery/ &

  echo "Adding grimoire files to $TARGET" >> /tmp/installer-debug
  cd $TARGET/var/lib/sorcery/codex; tar xjpf /var/lib/sorcery/codex/stable.tar.bz2 ; cd / 
  # installer uses "gaze version $*" so we need to make the grimoire available for it too
  mount --bind $TARGET/var/lib/sorcery/codex /var/lib/sorcery/codex

  echo "Adding grimoire to $TARGET/etc/sorcery/local/grimoire" >> /tmp/installer-debug
  echo "GRIMOIRE_DIR[0]=/var/lib/sorcery/codex/stable" > ${TARGET}/etc/sorcery/local/grimoire

  echo "Adding /var/state/sorcery/* files to $TARGET" >> /tmp/installer-debug
  cp  -f /var/state/sorcery/* ${TARGET}/var/state/sorcery
  rm ${TARGET}/var/state/sorcery/packages
  touch ${TARGET}/var/state/sorcery/packages

  echo "Generating /etc/fstab ... " >> /tmp/installer-debug
  make_fstab 
  mkdir -p ${TARGET}/mnt/{floppy,cdrom}

# add the date for the installation.
  echo "Adding installation date to /etc/source_mage-iso-release..." >> /tmp/installer-debug
  echo -e "This Source Mage GNU/Linux system installed from \n\t$VERSION ISO on \n`date --utc`" >> ${TARGET}/etc/source_mage-iso-release

# copy these files as they are untracked or SA generated
  echo "Adding /etc/* files to $TARGET" >> /tmp/installer-debug
  cp -f /etc/{passwd,group,ld.so.conf,services,protocols,issue,modules,modules.conf,nsswitch.conf,yp.conf} ${TARGET}/etc
  echo "Symlinking ${TARGET}/etc/init.d/runlevels/rc to /bin/true" >> /tmp/installer-debug
  ln -sf /bin/true ${TARGET}/etc/init.d/runlevels/rc

# setup libc tar and bzip2 so that chroot_install will work immediately
  echo "Adding tar, bzip2, libc, libpthread and librt  to $TARGET" >> /tmp/installer-debug
  cp -f /sbin/ldconfig ${TARGET}/sbin
  cp -f /usr/bin/bzip2 ${TARGET}/usr/bin
  cp -f /bin/tar ${TARGET}/bin
  cp -af /lib/{ld-*,libpthread*,libc.so.6,libc-*,librt*} ${TARGET}/lib
  # have already copied /etc/ld.so.conf , so ...
  chroot_cmd ldconfig

# adding root's config files to ${TARGET}
  cp -f /etc/skel/.* ${TARGET}/root/
  # secure default for the history file
  ln -sf /dev/null ${TARGET}/root/.bash_history

# setup the static /dev/ entries while the user configures the rest of the install
  echo "Setting up static /dev entries" >> /tmp/installer-debug
  cp -f /sbin/MAKEDEV ${TARGET}/dev && cd ${TARGET}/dev; ./MAKEDEV generic md ; mknod ${TARGET}/dev/initctl p ; mkdir -p {pts,shm} ; 
cd /
       
}

optional_spell_list () {

for spell in `cat /etc/installerdata/optional-list`
do echo $spell
   echo `gaze short $spell | tail -n +2`
   echo off
done

}

choose_optionals() {


  TITLE="Installer menu for selecting optional spells to install."
   HELP="Please select from the list of optional spells available. \
Dependencies will be added later if a spell needs them." 
  $DIALOG  --title     "$TITLE"     \
           --separate-output        \
           --checklist "$HELP"      \
           0 0 0                    \
	`optional_spell_list`

}

spell_select() {

echo "Sorcery is generating the optional spell menu, please wait ..." &&
echo "Generating menu for optional spells" >> /tmp/installer-debug    &&

# check that setup_target has atleast copied over the binaries for chroot_install to work, otherwise sleep 
while ! [ -e ${TARGET}/etc/ld.so.cache ] 
do echo "Waiting for setup to finish"
   sleep 2
done && 

OPTIONALS=`choose_optionals` &&

if [[ `uname -r` == 2.6.* ]] 
then PROMPT="Would you like to run udev on /dev or traditional static /dev ?"

    if `$DIALOG --no-label "static" --yes-label "udev" --nocancel --yesno "$PROMPT" 10 50` 
    then DEVICES=udev
    else DEVICES=static
    fi
    export DEVICES
    echo "chose ${DEVICES} for /dev" >> /tmp/installer-debug
fi    &&

# next stop last screen and installation
[ -n "$GUIDE" ] && DONE_CONFIG="YES"

echo "Optionally chose $OPTIONALS for installation" >> /tmp/installer-debug

}

service_list() {

ALLSCRIPTS=`find ${TARGET}/etc/init.d/runlevels/%*/ | grep -v runlevel.config`
for initscript in $ALLSCRIPTS
do if [ -f $initscript ]
   then echo "`echo $initscript | cut -d/ -f8` "
        echo "Runlevel `echo $initscript | cut -d/ -f7 | sed s:%::`"
        if [ -x $initscript ]
        then echo "on"
        else echo "off"
        fi
  fi
done

}

service_choose() { 

  TITLE="Installer menu for selecting initscripts to run at boot."
   HELP="Please select from the list of initscripts available. \
an X means they are currently enabled (maybe for a good reason !)." 
  $DIALOG  --title     "$TITLE"     \
           --separate-output        \
           --checklist "$HELP"      \
           0 0 0                    \
	`service_list`

}

service_select() {
 
echo "Running menu selection of services to start at boot" >> /tmp/installer-debug &&
SERVICES=`service_choose` &&
for initscript in $(echo ${TARGET}/etc/init.d/runlevels/%*/* | tr ' ' '\n' | grep -v runlevel.config | cut -d/ -f8)
do if echo $SERVICES | grep -q "$initscript "
   then chroot_cmd telinit bootenable "$initscript" > /dev/null
        echo "Marking $initscript to start at boot ..."
   else chroot_cmd telinit bootdisable "$initscript" > /dev/null
        echo "Disabling starting of $initscript at boot ... " 
   fi
done        &&

[ -n "$GUIDE" ] && ICOMMAND="X"

}

install_to_target()  {

  PROMPT="Are you ready to install ?"

  if  confirm  "$PROMPT"
  then echo  "Installing Source Mage GNU/Linux."

    # now install the default spells 
       for default_spell in $(cat /etc/installerdata/install-list)
       do chroot_install $default_spell
       done &&
       
    # make network the network provider
       sed -i -e s/network=.*/network=network/ ${TARGET}/etc/sysconfig/facilities

    # reinstall the resolve.conf in case downloading is wanted for compile_kernel
       cp -f /etc/resolv.conf ${TARGET}/etc/       
       
    # check which fs spells are needed
       USED_FS=`cat ${TARGET}/etc/fstab | awk '{print $3}' | uniq`
       unset FS_PROGS
       for i in $USED_FS
       do case "$i" in
                "xfs" )      FS_PROGS="xfsprogs $FS_PROGS"      ;;
           "reiserfs" )      FS_PROGS="reiserfsprogs $FS_PROGS" ;;            
                "jfs" )      FS_PROGS="jfsutils $FS_PROGS"      ;;
          esac
       done

       if cat ${TARGET}/etc/fstab | awk '{print $1}' | grep -q md 
       then if [ -s /etc/raidtab ]
            then cp -f /etc/raidtab ${TARGET}/etc/raidtab
                 FS_PROGS="raidtools $FS_PROGS"
            fi
       fi

    # install the used fs spells
       if [ $FS_PROGS ] && [ -z "$DEBUG" ]
       then for fsinstall in `echo $FS_PROGS| tr ' ' '\n'`
            do chroot_install $fsinstall
               chroot_newdep  $fsinstall
            done
       fi
       echo "Installing used filesystem spells $FS_PROGS" >> /tmp/installer-debug

    # install EDITOR BOOTLOADER LOGGER and the networking spells 
       chroot_install ${REAL_ED}
         chroot_newdep ${REAL_ED} #frikkin jed and slang !
       chroot_install ${BOOTLOADER}
       if [ "${BOOTLOADER}" = grub ] 
       then cp -af ${TARGET}/usr/share/grub/i386-pc/* ${TARGET}/boot/grub/
            find_grub_root > /tmp/grub  
            find_grub_target            
            grub_install                
            echo -e "grub installed to \"${grub_target}\"" >> /tmp/installer-debug
             # if these don't exist, user gets poleaxed when they rebuild/upgrade grub
            echo "RUN_GRUB=n" > ${TARGET}/etc/sorcery/local/depends/grub
            echo "GRUB_ROOT=\"${grub_root}\"" >> ${TARGET}/etc/sorcery/local/depends/grub
            echo "GRUB_TARGET=\"${grub_target}\"" >> ${TARGET}/etc/sorcery/local/depends/grub
            echo -e "grub fields written to ${TARGET}/etc/sorcery/local/depends/grub" >> /tmp/installer-debug           
       fi
       if [[ $LOGGER != none ]]
       then chroot_install $LOGGER
            chroot_newdep  $LOGGER
            [[ $LOGGER == metalog ]] && sed -i -e s/syslog=/syslog=smgl-$LOGGER/ ${TARGET}/etc/sysconfig/facilities
            [[ $LOGGER == sys* ]] && sed -i -e s/syslog=/syslog=$LOGGER/ ${TARGET}/etc/sysconfig/facilities
       fi

    # install the required networking spells
       echo "Installing networking spells; $NETTAGE" >> /tmp/installer-debug  
       for netspell in `echo $NETTAGE|tr ' ' '\n'`
       do chroot_install $netspell
          chroot_newdep  $netspell
          [[ "$netspell" == *ppp* ]] && cp -af /etc/ppp ${TARGET}/etc/
       done

    # install the optional spells that were selected
       for extraspell in `echo $OPTIONALS | tr ' ' '\n'`
       do chroot_install $extraspell
          chroot_newdep $extraspell
          if [[ $extraspell == openssh* ]]
          then mkdir -p ${TARGET}/etc/xinetd.d
               cp -f /etc/xinetd.d/openssh ${TARGET}/etc/xinetd.d
               mkdir -p ${TARGET}/etc/ssh
               # hehe want the keys to be unique, not same on every $VERSION install :)
               # this is same as openssh's Makefile running "make host-key"
               rm -f /etc/ssh/*host*
               ssh-keygen -t rsa1 -f /etc/ssh/ssh_host_key -N ""
               ssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_key -N ""
               ssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key -N ""
               cp -af /etc/ssh/* ${TARGET}/etc/ssh/
          fi
          [[ $extraspell == devfsd* ]] && cp -f /etc/devfsd.conf ${TARGET}/etc/
          [[ $extraspell == xinetd* ]] && cp -f /etc/xinetd.conf ${TARGET}/etc/ && mkdir -p ${TARGET}/var/log/xinetd
          [[ $extraspell == distcc* ]] && chroot_install xinetd && cp -f /etc/xinetd.d/distccd ${TARGET}/etc/xinetd.d && \
          echo "distcc		3632/tcp" >>${TARGET}/etc/services && mkdir -p ${TARGET}/var/log/xinetd
          [[ $extraspell == links* ]] && chroot_install openssl 
          [[ $extraspell == uptimed* ]] && mkdir -p ${TARGET}/var/spool/uptimed/ 
       done
       if grep -q portmap ${TARGET}/var/state/sorcery/packages
       then sed -i -e 's/^portmap=.*$/portmap=portmap/' ${TARGET}/etc/sysconfig/facilities
       fi &&
    # install udev if DEVICES=udev
       if [[ "$DEVICES" == udev ]]
       then chroot_install udev
            chroot_newdep  udev
            chroot_install which
       fi &&

       touch                                ${TARGET}/proc/mounts

 # installing the keymap chosen in keymap_menu() or the default one: us

    KEYMAP=${KEYMAP:-us}
    sed -i -e  s/KEYMAP=.*/KEYMAP=${KEYMAP}/  ${TARGET}/etc/sysconfig/keymap &&

 # install the users choice of editor ($REAL_ED) to the system profile.d dir

        cat >> "${TARGET}/etc/profile.d/editor.sh" <<EOF &&
#!/bin/bash
# Added by $0
# First check if this variable is already set
# then if not set, check it (maybe), then set it

if  [ -z "\$EDITOR" ] ; then
        EDITOR="$REAL_ED"
fi
export EDITOR

EOF

# installing the chosen LANG to the system profile.d dir

    cat >> "${TARGET}/etc/profile.d/lc.sh" <<EOF &&
#!/bin/bash
# Added by $0
# First check if this variable is already set
# then if not set, check it (maybe), then set it

if  [ -z "\$LANG" ] ; then
        LANG="$LANG"
fi
export LANG

EOF

# copy the default kernel now

    [ "$KERNEL" = copy ] && copy_kernel
   
    if [[ `uname -r` == 2.6.* ]]
    then sed -i -e s/DEVICES=.*/DEVICES=$DEVICES/ ${TARGET}/etc/sysconfig/devices
    else sed -i -e s:/dev/tty:/dev/vc/: ${TARGET}/etc/inittab
    fi &&


    $DIALOG  --trim  --msgbox "The system and your chosen spells have been installed to ${TARGET}.\n
Next enter the password for the root account and if you chose to compile a kernel, that happens last."  20 60 ||
    sleep 10

    if [ -z "$DEBUG" ]
    then echo "Last thing to do: choose root password:" 
         chroot_cmd passwd root
         chmod 400 ${TARGET}/etc/shadow
    fi &&
    echo "chrooting and changing root password" >> /tmp/installer-debug

 # compile custom kernel here
    [ "$KERNEL" = compile ] && compile_kernel

    DONE_INSTALLED=yes
  fi &&

[ -n "$GUIDE" ] && ICOMMAND="U"

}


make_kernel()  {
  # install the config used for this kernel
    cp -f /boot/config* ${TARGET}/etc/sorcery/local/ISO-kernel.config

COMPILE_HELP="A custom kernel might be needed for your hardware needs"
COPY_HELP="The default kernel is extrememly modular."
TITLE="Installer menu for kernel installation for x86."
    HELP="Would you like to configure and compile a custom kernel,\nor install the precompiled kernel from the ISO ?\
\n(Actual compilation/copying will happen after the spell installation)"
  KERNEL=`$DIALOG  --title     "$TITLE"                                   \
           --item-help                                                    \
           --radiolist "$HELP"                                            \
           12 60 0                                                        \
	"compile" "custom built $(uname -r) kernel" "off" "$COMPILE_HELP" \
        "copy"    "precompiled $(uname -r) kernel"  "on"  "$COPY_HELP"`   &&

export KERNEL                                                             &&

# next stop logger config
[ -n "$GUIDE" ] && ICOMMAND="L"

}

compile_kernel() {

  $DIALOG  --cr-wrap --textbox  /etc/installerdata/kernel.help 22 78
  if [ -z "$DEBUG" ]
  then rm -rf ${TARGET}/usr/src/linux*
       chroot_cmd cast -c linux
       # lilo is automatically run after cast linux and grub is dynamic
  fi   &&

  echo "compiling custom kernel" >> /tmp/installer-debug
}

copy_kernel() {

 # generic kernel copying and packages listing
    echo "Installing default kernel linux-`uname -r` ..." 
    echo "Installing default kernel linux-`uname -r` ..." >> /tmp/installer-debug

 if [ -z "$DEBUG" ] ; then
    echo "Installing kernel image to /boot" >> /tmp/installer-debug
    cp -vf /boot/linux ${TARGET}/boot/vmlinubz-`uname -r`
    ln -sf vmlinubz-`uname -r` ${TARGET}/boot/vmlinubz

    echo "Installing kernel modules directory " >> /tmp/installer-debug
    mkdir -p ${TARGET}/lib/modules/
    cp -avf /lib/modules/`uname -r` ${TARGET}/lib/modules/

    echo "Installing kernel includes to ${TARGET}/usr/src" >> /tmp/installer-debug
    cd ${TARGET}/usr/src ; bunzip2 -dc /usr/src/linux-`uname -r`-includes.tar.bz2 | tar xvf - ; cd /
     # to stop reporting time errors on first boot
    touch ${TARGET}/lib/modules/`uname -r`/modules.dep

    echo "Installing kernel logs" >> /tmp/installer-debug
    cp -f /var/log/sorcery/install/linux-`uname -r` ${TARGET}/var/log/sorcery/install/
    cp -f /var/log/sorcery/md5sum/linux-`uname -r` ${TARGET}/var/log/sorcery/md5sum/
    echo "linux:`date +%Y%m%d`:installed:`uname -r`" >> ${TARGET}/var/state/sorcery/packages

 # system has been installed, run lilo now
    if [ "${BOOTLOADER}" = lilo ]
    then chroot_cmd /sbin/lilo -v 
    fi
  fi

  echo "copied default kernel" >> /tmp/installer-debug

}


shell() {

  echo  "Press CTRL-D or type exit to return to the installer"
  /bin/sh

}


ethernet()  {

       DHCPCD_PROMPT="Will you require DHCPCD ?"
     PCMCIA_PROMPT="Will you require PCMCIA ?"
     WIRELESS_PROMPT="Will you require wireless_tools ?"

  if  confirm  "$PCMCIA_PROMPT" --defaultno ;  then
      NETTAGE="$NETTAGE pcmcia-cs"
  fi &&
  
  if  confirm  "$DHCPCD_PROMPT" --defaultno ;  then
      NETTAGE="$NETTAGE dhcpcd"
  fi &&
  
  if  confirm  "$WIRELESS_PROMPT" --defaultno ;  then
      NETTAGE="$NETTAGE wireless_tools"
  fi &&

# call netconf to configure networking
  /usr/sbin/netconf && cp -af /etc/sysconfig/network ${TARGET}/etc/sysconfig &&
  echo "Running netconf" >> /tmp/installer-debug &&

PROMPT="Start that interface now ?" 
if confirm "$PROMPT"
then telinit run network restart
     cp -f /etc/resolv.conf  ${TARGET}/etc/       &&
     echo "starting ethernet interface" >> /tmp/installer-debug
else echo "declined to start ethernet interface" >> /tmp/installer-debug
fi

}


ppp()  {
     unset NETTAGE
     DHCPCD_PROMPT="Will you require DHCPCD ?"           &&
     PCMCIA_PROMPT="Will you require PCMCIA ?"           &&
     WIRELESS_PROMPT="Will you require wireless_tools ?" &&
     PPPOE_PROMPT="Will you require rp-pppoe ?"          &&
     
  if  confirm  "$PCMCIA_PROMPT" --defaultno ;  then
      NETTAGE="$NETTAGE pcmcia-cs"
  fi &&
    if confirm  "$DHCPCD_PROMPT" --defaultno ;  then
      NETTAGE="$NETTAGE dhcpcd"
  fi &&
  if confirm "$WIRELESS_PROMPT" --defaultno ; then
     NETTAGE="$NETTAGE wireless_tools"
  fi &&
  if confirm "$PPPOE_PROMPT" --defaultno ; then
      NETTAGE="$NETTAGE rp-pppoe"
  fi &&

  USERNAME_PROMPT="Enter ISP username"
  PASSWORD_PROMPT="Enter ISP password"
    NUMBER_PROMPT="Enter ISP phone number without dashes, spaces and parenthesis"
      PORT_PROMPT="Enter serial port device"
              ISP="/etc/ppp/chat/isp"

         USERNAME=`inputbox  "$USERNAME_PROMPT"`             &&
         PASSWORD=`inputbox  "$PASSWORD_PROMPT"`             &&
           NUMBER=`inputbox  "$NUMBER_PROMPT"    "5555555"`  &&
             PORT=`inputbox  "$PORT_PROMPT"      "ttyS0"`    &&

  sed -i -e "s/5555555/$NUMBER/"             "$ISP"             &&
  sed -i -e "s/: username/: $USERNAME/"      "$ISP"             &&
  sed -i -e "s/qpassword/q$PASSWORD/"        "$ISP"             &&
  ln  -sf  $PORT  $TARGET/dev/modem                             &&
  ln  -sf  $PORT  /dev/modem                                    &&
  

PROMPT="Start that interface now ?"                       &&
if confirm "$PROMPT"
then pon isp
     cp -f /etc/resolv.conf  ${TARGET}/etc       &&
     echo "starting ppp interface" >> /tmp/installer-debug
else echo "declined to start ppp interface" >> /tmp/installer-debug
fi

}


pppoe()  {
        unset NETTAGE

     DHCPCD_PROMPT="Will you require DHCPCD ?"
     PCMCIA_PROMPT="Will you require PCMCIA ?"
     WIRELESS_PROMPT="Will you require wireless_tools ?"

  if  confirm  "$PCMCIA_PROMPT" --defaultno ;  then
      NETTAGE="$NETTAGE pcmcia-cs"
  fi &&
  
  if  confirm  "$DHCPCD_PROMPT" --defaultno ;  then
      NETTAGE="$NETTAGE dhcpcd"
  fi &&
  
  if  confirm  "$WIRELESS_PROMPT" --defaultno ;  then
      NETTAGE="$NETTAGE wireless_tools"
  fi &&

  if [ -z "$DEBUG" ]
  then  adsl-setup
  fi                 &&
  echo "Setting up adsl via adsl-setup" >> /tmp/installer-debug &&

PROMPT="Start that interface now ?"  &&
if confirm "$PROMPT"
then adsl-start
     cp -f /etc/resolv.conf  ${TARGET}/etc       &&
     echo "starting adsl interface" >> /tmp/installer-debug
else echo "declined to start adsl interface" >> /tmp/installer-debug
fi


}

syslog()  {

    TITLE="Please select your system logger"
    HELP="There are 3 loggers available"
    SYSKLOGD_HELP="This version of syslogd is similar to the standard Berkeley product."
    SYSLOGNG_HELP="syslog-ng, as the name shows, is a syslogd replacement."
    METALOG_HELP="Metalog is a modern replacement for syslogd and klogd."
    NONE_HELP="Don't want a logger, or don't know which one to pick."

    LOGGER=`$DIALOG   --title "$TITLE"                  \
                      --item-help                       \
	              --radiolist                       \
                      "$HELP"                           \
                      0 0 0                             \
                      "sysklogd" ""  "off" "$SYSKLOGD_HELP"     \
                      "syslog-ng" "" "off" "$SYSLOGNG_HELP"     \
                      "metalog" ""   "off" "$METALOG_HELP"      \
                      "none" ""      "off" "$NONE_HELP"`        &&


 export LOGGER                                          &&

 echo "Chose $LOGGER for the system logger" >> /tmp/installer-debug  &&

# next stop bootloader config

 [ -n "$GUIDE" ] && ICOMMAND="M"

}


network()  {

    # chroot call netconf to configure hostname (we need to remove the file /etc/hostname first)
    if [ -z "$DEBUG" ] 
    then rm -f /etc/hostname &&
         /usr/sbin/netconf --check_hostname
    fi
    echo "hostname is `cat /etc/hostname`" >> /tmp/installer-debug
    cp -f /etc/hostname ${TARGET}/etc/hostname

    E_HELP="Use a network interface card, NIC?"
    P_HELP="Point to Point Protocol is for modem networking."
    R_HELP="Roaring Penguin PPP over Ethernet, for ADSL connections?"
  NET_HELP="How will this box connect to the Internet?"

  COMMAND=`$DIALOG  --title "Networking Protocol"  \
                    --nocancel                     \
                    --item-help                    \
                    --menu                         \
                    "$NET_HELP"                    \
                    0 0 0                          \
                    "E"  "Ethernet"  "$E_HELP"     \
                    "P"  "PPP"       "$P_HELP"     \
                    "R"  "PPPoE"     "$R_HELP"`    &&

  case  $COMMAND  in
    E)  ethernet  ;;
    P)  ppp       ;;
    R)  pppoe     ;;
  esac &&

# reset hostname to users
hostname `cat /etc/hostname` &&

# next stop select optional spells
[ -n "$GUIDE" ] && ICOMMAND="O"

}


toggle_guide()  {

  [  -n  "$GUIDE"  ]  &&
  unset  GUIDE        ||
  GUIDE="on"

}


toggle_confirm()  {

  [  -n  "$CONFIRM"  ]  &&
  unset  CONFIRM        ||
  CONFIRM="on"

}


show_consolefonts()  {

  FONTDIR="/usr/share/consolefonts"
  cd  $FONTDIR

  FONTS=`ls  *.gz  |  sed  "s/\.psf\.gz//"`

  for  FONT  in  $FONTS;  do
    echo  "${FONT}"
    echo  "font "
  done

}


font_menu()  {

     TITLE="Console Font Selection Menu"
      HELP="Please select your preferred console fonts."
     FONTS=`show_consolefonts`
 
      FONT=`$DIALOG  --title  "$TITLE"   \
                     --menu   "$HELP"    \
                     0 0 0               \
                     $FONTS`             &&
  
 CONSOLECHARS="consolechars  -f  $FONT"  &&
 consolechars  -f  $FONT

}


show_languages()  {
    IDX=0

    cd /usr/share/i18n/locales
    for lang in *;
    do
      title=`grep "^title" "${lang}" | cut -d '"' -f 2`

      if [ -n "${title}" ]; then

          LANGS[$((IDX++))]="${lang}"
          LANGS[$((IDX++))]="${title} "

      fi
    done

}

lang_menu()  {

    TITLE="Language Selection Menu"
     HELP="While sorcery is entirely in English 
it is possible to change the languages of many other programs.
Please select your preferred language."

     show_languages &&
     LANG=`$DIALOG  --title  "$TITLE"   \
                    --menu   "$HELP"    \
                    0 0 0               \
                    "${LANGS[@]}"` &&
    export LANG
    echo "Chose LANG=$LANG" >> /tmp/installer-debug
}


editor_menu()  {

  ELVIS_HELP="elvis is a clone of the ex/vi text editor"
    JED_HELP="jed is an editor with emulation for emacs, EDT, and Wordstar"
   NANO_HELP="nano is an enchanced free pico clone"
    VIM_HELP="VIM is an improved version of vi"

        HELP="The Install/Rescue disc provides 2 easy to use editors, elvis and nano.\n
4 common editors can be installed, although selecting jed or vim will still use elvis during the install"
       TITLE="Editor Selection Menu"

  EDITOR=`$DIALOG  --title  "$TITLE"                \
                   --item-help                      \
                   --radiolist   "$HELP"            \
                   0 0 0                            \
                   "vim"    "" "off" "$VIM_HELP"    \
                   "elvis"  "" "off" "$ELVIS_HELP"  \
                   "jed"    "" "off" "$JED_HELP"    \
                   "nano"   "" "off"  "$NANO_HELP"`

# only nano and elvis are in iso_root, so rename the EDITOR and set vim and jed to use elvis
  export  REAL_ED=$EDITOR
  if [ "$EDITOR" = "vim" ] || [ "$EDITOR" = "jed" ]
  then EDITOR=elvis
  fi

  export  EDITOR

  echo "chose $EDITOR as EDITOR" >> /tmp/installer-debug
 
}


nls()  {

  while
    
      FONT_HELP="Select a new default console font."
    KEYMAP_HELP="Select a new default keyboard mapping. KEYMAP=$KEYMAP"
      LANG_HELP="Select a new default language. LANG=$LANG"
    EDITOR_HELP="Select a new default editor. EDITOR=$REAL_ED"
           HELP="Select the options to make your SMGL box more friendly."
          TITLE="Native Language Support Menu"

    COMMAND=`$DIALOG  --cancel-label  "Continue"                 \
                      --ok-label "Select"                       \
                      --title  "$TITLE"                          \
                      --item-help                                \
                      --menu  "$HELP"                            \
                      0 0 0                                      \
                      "Font"    "Font     Menu "  "$FONT_HELP"   \
                      "Keymap"  "Keymap   Menu "  "$KEYMAP_HELP" \
                      "Lang"    "Language Menu "  "$LANG_HELP"   \
                      "Editor"  "Editor   Menu "  "$EDITOR_HELP"`
  do
  
    case  $COMMAND in
        Keymap)  keymap_menu  ;;
          Font)  font_menu    ;;
          Lang)  lang_menu    ;;
        Editor)  editor_menu  ;;
    esac

  done

}


show_timezones()  {

  for  ITEM  in  `ls  $LOCALTIME/$1`;  do

    if  [  -n  "$1"  ];  then  echo  "$1/$ITEM"
                         else  echo     "$ITEM";  fi

    if  [  -d  $LOCALTIME/$1/$ITEM  ];  then  echo  "Directory "
                                        else  echo  "Timezone ";  fi
  done
  
}


timezone()  {

# being the first menu item after mounting, ask the user if it's ok to run setup_target in the background

  PROMPT="Are you done mounting file systems ?\n(Answering yes means some system files and directories will be installed in the \
background while you configure the rest of the install)"

  if [ -z $DONE_SETUP ]
  then if  confirm  "$PROMPT"
       then if ! echo $FS_LIST | grep -q swap
            then PROMPT="Make swapfile, since you have no dedicated swap partition ?"
                if confirm "$PROMPT"
                then mk_swap_file
                fi
            fi 
            setup_target 2>/dev/null & # redirect errors to /dev/null and return shell to the installer
            DONE_SETUP=yes
       else return 1
       fi
  fi       &&

  LOCALTIME="/usr/share/zoneinfo"
      TITLE="Time Zone Selection Menu"
       HELP="Select timezone or directory"
       ZONE=""

  while  TIMEZONES=`show_timezones  $ZONE` &&
         ZONE=`$DIALOG  --title  "$TITLE"  \
                        --menu             \
                        "$HELP"            \
                        0 0 0              \
                        $TIMEZONES`        &&
    [  -d  "${LOCALTIME}/${ZONE}"  ]

  do true
  done

  if  [ -f "${LOCALTIME}/${ZONE}" ]; then

# configure the local time zone
    ln  -sf  "${LOCALTIME}/${ZONE}" "${TARGET}/etc/localtime"
# and /etc/ is writable now too
    ln  -sf  "${LOCALTIME}/${ZONE}" /etc/localtime

    TITLE="GMT or Local"
     HELP="Does the hardware clock store time in GMT or local?"

    CLOCK=`$DIALOG  --title  "$TITLE"  \
                    --menu   "$HELP"   \
                    0 0 0              \
                    "GMT"    ""        \
                    "Local"  ""`
    case  $CLOCK  in
        GMT)
            UTC=yes
            ;;

        Local)
            UTC=no
            ;;
    esac

# select if the hardware clock is UTC or not
cat > ${TARGET}/etc/sysconfig/hwclock <<EOF
# does the hardware clock store the time in UTC
UTC=${UTC}
EOF
  echo "adding UTC=${UTC} to /etc/sysconfig/hwclock" >> /tmp/installer-debug
  fi     &&

# next stop architecture and opts
[ -n "$GUIDE" ] && ICOMMAND="H"

}

find_grub_root() {
touch ${TARGET}/boot/test-for-bootloc &&

${TARGET}/sbin/grub --batch << EOF
find ${BOOTLOC}/test-for-bootloc
EOF

}

find_grub_target() {
  rm -f ${TARGET}/boot/test-for-bootloc
  grub_root=`grep hd /tmp/grub | head -n 1`
  [[ "${MBR}" == "YES" ]] && grub_target=\(`echo ${grub_root} | sed -e 's/[ ()]//g' | cut -d, -f1`\)
  [[ "${MBR}" != "YES" ]] && grub_target=${grub_root}
  export grub_root 
  echo -e "grub_root is \"${grub_root}\"" >> /tmp/installer-debug
  export grub_target
  echo -e "grub_target is \"${grub_target}\"" >> /tmp/installer-debug

}

grub_install() {
# should grub mark it as active if MBR=y ?

${TARGET}/sbin/grub --batch << EOF
root  ${grub_root}
setup ${grub_target}
EOF

}

choose_bootloader() {

GRUB_HELP="GNU GRUB is a Multiboot boot loader. It was derived from GRUB, GRand Unified Bootloader"
LILO_HELP="lilo is a boot loader for Linux/x86 and other PC operating systems."
TITLE="Installer menu for selecting bootloader for x86."
   HELP="Please select the bootloader for your machine."
  $DIALOG  --title     "$TITLE"     \
           --item-help              \
           --radiolist "$HELP"      \
           0 0 0                    \
	"grub" "GNU GRUB bootloader" "off" "$GRUB_HELP" \
        "lilo" "the LInux LOader"    "off" "$LILO_HELP"

}

config_bootloader() {

if [ -z "$BOOTLOADER" ] 
then BOOTLOADER=`choose_bootloader` 
fi                                                     &&
export BOOTLOADER                                      &&

PROMPT="Install ${BOOTLOADER} to the MBR of the /boot drive (answer Yes) \nor to the boot sector of the /boot partition (answer No) ?" &&

if confirm "$PROMPT" --defaultno
then export MBR=YES
fi                                                     &&
    if [ -z "$DONE_INSTALLED" ]
    then if [ "$ARCH" = "ppc" ]
         then make_yaboot_conf
              config_yaboot
         else make_${BOOTLOADER}_conf
         fi
    else if [ "$ARCH" = "ppc" ]
         then config_yaboot
         else config_${BOOTLOADER} &&
              [ "$BOOTLOADER" = lilo ] && chroot_cmd /sbin/lilo -v
#grub already installed but if MBR option changed then we need to reinstall it
              if [ "${BOOTLOADER}" = grub ] && [ -z "$DEBUG" ]
              then find_grub_root > /tmp/grub &&
                   find_grub_target           &&
                   grub_install               &&
                   echo -e "grub installed to \"${grub_target}\"" >> /tmp/installer-debug
              fi
              sleep 15 # delay so lilo errors can be read
         fi
    fi                                       &&

# next stop network config
[ -n "$GUIDE" ] && ICOMMAND="N"

}

config_lilo()  {

  $DIALOG --cr-wrap --msgbox  \
"SMGL installs LILO to the first sector of /boot.  If you
prefer that LILO be installed to the MBR, Master Boot
Record, then edit /etc/lilo.conf and change the boot= 
so that the last word is disc instead of part?.
For RAID 1 arrays change boot= to a disc in the array or even the first disk on the machine"  20 60 &&

  EDITOR="${EDITOR:-nano}"                                                                          &&
  ${EDITOR} ${TARGET}/etc/lilo.conf                                                                 &&
  echo "editing lilo  configuration file" >> /tmp/installer-debug

}

config_grub()  {

  $DIALOG --cr-wrap --no-label "Return" --yes-label "Continue" --nocancel --yesno \
"SMGL by default installs GRUB to the first sector of /boot.  If you
prefer that GRUB be installed to the MBR, Master Boot Record,
then return to the main menu, rerun \"Configure ${BOOTLOADER}\" and choose to
install to the MBR. MBR for RAID 1 arrays is the first disk in the array, unless a separate /boot partition is made.
You may now view/edit the generated grub.conf."  20 60            &&

  EDITOR="${EDITOR:-nano}"                                        &&
  ${EDITOR} ${TARGET}/boot/grub/grub.conf                         &&
  echo "editing grub configuration file" >> /tmp/installer-debug

}


config_yaboot()  {

  $DIALOG --cr-wrap --msgbox  \
"You can now reconfigure /etc/yaboot.conf. \
Feel free to do it, at your own risk."  20 45

  EDITOR="${EDITOR:-nano}"
  chroot_cmd "${EDITOR}" /etc/yaboot.conf

#  BD_PROMPT="Please select your bootstrap partition"
#  BD=`$DIALOG  --nocancel                     \
#                 --inputbox                     \
#               "$BD_PROMPT" 10 40 "/dev/discs/disc0/part2"`
#  OFW_PROMPT="Please enter your OF device (e.g. hd:2)"
#  OFW=`$DIALOG  --nocancel                     \
#                 --inputbox                     \
#               "$OFW_PROMPT" 10 40  hd:2`

  chroot_cmd /usr/sbin/ybin -b ${BD} -o ${OFW} 
  # Give enough time to actually see messages
  sleep 2
}


install_help()  {

  $DIALOG --cr-wrap --textbox /etc/installerdata/install.guide  21 78

}

restart_install() {
# unset all these
# ppc specific variables
       unset BD
       unset OFW
       unset RT
#common
       unset DEBUG
       unset FS_LIST
       unset mount_command
       unset FS_STRING
       unset FSTAB_ENTRY
       unset USED_FS
       unset UNUSED_FS
       unset EDITOR
       unset REAL_ED
       unset LANG
       unset UTC
       unset CLOCK
       unset MAP
       unset ZONE
       unset FONT
       unset KEYMAP
       unset ITEM
       unset LOCALTIME
       unset LINE
       unset LIST
       unset BOOT
       unset ROOT
       unset NETTAGE
       unset LOGGER
       unset PLACE
       unset RAIDLEVEL
       unset RAID_PARTS
       unset RD_PARTS
       unset RD_DISC
       unset ind_disk
       unset rd_device
       unset part
       unset raiddev
       unset RDEV
       unset MAKE_JOBS
       unset MAKE_NJOBS
       unset DONE_INSTALLED
       unset DONE_CONFIG
       unset DONE_SETUP
       unset extraspell
       unset default_spell
       unset spell
       unset fsinstall
       unset FS_PROG
       unset newdep
       unset OPTIONALS
       unset ALLSCRIPTS
       unset SERVICES
       unset initscript
       unset BOOTLOADER
       unset MBR
       unset BOOTLOC
       unset grub_root
       unset grub_target
       unset DEVICES
       unset SWAPON
       unset KERNEL

umount -f /var/lib/sorcery/codex 2>/dev/null
# first unmount already mounted filesystems 
for mounted_part in `mount | awk ' { print $3}' | grep /mnt/root | sort -r`
do umount -f $mounted_part 2>/dev/null
done

# then when unmounted, stop raid arrays
for RDEV in `grep raiddev /etc/raidtab | awk '{print $2}'`;
do raidstop $RDEV
done

# now remove raid temporary files so the restart works on all partitions
rm -f /tmp/raid*
rm -f /etc/raidtab
# and the installer-debug log if it exists
rm -f /tmp/installer-debug
swapoff -a

# reset these to the defaults
       export CONFIRM=on
       export GUIDE=on
       ICOMMAND="B"

}

toggle_debug() {

[ -n "$DEBUG" ] && 
unset DEBUG || 
DEBUG="on"

}

install_menu()  {

 ICOMMAND="B"

 while

     TITLE="Install Menu - for $ARCH architecture"
    A_HELP="Read about the advantages of using Source Mage GNU/Linux"
    B_HELP="Select default language, keymap, and console fonts"
    if [ "$ARCH" = "ppc" ]
	then
	C_HELP="Use mac-fdisk to prepare hard drive partitions"
	else
	C_HELP="Use fdisk, cfdisk or parted to prepare hard drive partitions"
    fi
    D_HELP="Mount and initialize file systems and swap partitions"
    E_HELP="Optionally make software RAID device from existing partitions or discs"
    F_HELP="SMGL recommends 1GB of RAM + SWAP (swap partition or swap file)"
    G_HELP="Select timezone for translating GMT into local time"
    H_HELP="Select architecture and optimizations"
    I_HELP="Copy the distro from CDROM to fixed disk"
    J_HELP="Oops-a-daisy, I forgot I need special drivers... :-)"
    K_HELP="Configure and install the Linux Kernel or copy the default from the ISO"
    L_HELP="Select the daemon for system logging"
    if [ "$ARCH" = "ppc" ] 
	then
	M_HELP="Edit $TARGET/etc/yaboot.conf and run ybin"
	else
	M_HELP="Choose a bootloader and edit it's config"
    fi
    N_HELP="Configure PPP or Ethernet TCP/IP networking"
    O_HELP="Select from a list of spells to optionally install."
    Q_HELP="When ready you may transfer Source Mage from CD to fixed disk."
    S_HELP="Shell out for a moment"
    P_HELP="Enable or disable guided menu"
    T_HELP="Enable or disable asking of confirmation questions"
    U_HELP="Select which of the installed services should start at boot."
    IG_HELP="Read an Installation Guide"
    R_HELP="Reset all variables and restart Installation"
    Z_HELP="Turn on debug, to test installer without performing any volatile commands"
    V_HELP="Guided menu disabled.  Nothing will prevent you from choosing \
options in a nonsensical sequence.  Good Luck."
    W_HELP="Abort now if you have not made backups.  Source Mage GNU/Linux \
comes with absolutely no warranty.  Run this script only when \
booted from the Source Mage CD.  Proceed at your own risk."
    X_HELP="Exit to a manual installation or reboot"
    Y_HELP="Select timezone, architecture optimizations, choose kernel, syslogger, bootloader and network interfaces.\n
Then select the optional spells for installation."

    if    [  -z  "$GUIDE"  ];  then
#full unguided menu
      ICOMMAND=`$DIALOG  --title  "$TITLE"                         \
                         --nocancel                                \
                         --default-item  $ICOMMAND                 \
                         --item-help                               \
                         --menu                                    \
                         "$V_HELP"                                 \
                         22 60 14                                  \
                         "A"  "Introduction"            "$A_HELP"  \
                         "B"  "Native Language Support" "$B_HELP"  \
                         "C"  "Partition Drive"         "$C_HELP"  \
                         "E"  "[Optionally] Make RAID device" "$E_HELP" \
                         "D"  "Mount Filesystems and swap" "$D_HELP"  \
                         "F"  "[Optionally] Make Swapfile" "$F_HELP"  \
                         "G"  "Select Timezone"         "$G_HELP"  \
                         "H"  "Architecture Optimize"   "$H_HELP"  \
                         "K"  "Install/Configure Linux Kernel"  "$K_HELP"  \
                         "L"  "Configure Log System"    "$L_HELP"  \
                         "M"  "Configure Bootloader"    "$M_HELP"  \
                         "N"  "Configure Networking"    "$N_HELP"  \
                         "O"  "Select optional spells to install" "$O_HELP" \
                         "I"  "Install Source Mage GNU/Linux"    "$I_HELP"  \
                         "U"  "Choose services to run at boot" "$U_HELP" \
                         "X"  "Done"                    "$X_HELP"  \
                         "S"  "Shell"                   "$S_HELP"  \
                         "P"  "Enable Guided Menu"      "$P_HELP"  \
                         "T"  "Toggle Confirm"          "$T_HELP"  \
                         "R"  "Restart Installation"    "$R_HELP"  \
                         "Z"  "Debug mode"              "$Z_HELP"  \
                         "?"  "Installation help notes" "$IG_HELP"`


    elif  [  -z  "$ROOT"  ];  then
#initial guided menu
      ICOMMAND=`$DIALOG  --title  "$TITLE"                         \
                         --nocancel                                \
                         --default-item  $ICOMMAND                 \
                         --item-help                               \
                         --menu                                    \
                         "$W_HELP"                                 \
                         20 60 10                                  \
                         "A"  "Introduction"            "$A_HELP"  \
                         "?"  "Installation Help"       "$IG_HELP" \
                         "R"  "Restart Installation"    "$R_HELP"  \
                         "B"  "Native Language Support" "$B_HELP"  \
                         "C"  "Partition Drive"         "$C_HELP"  \
                         "E"  "[Optionally] Make RAID device" "$E_HELP" \
                         "D"  "Mount Filesystems and swap" "$D_HELP"  \
                         "X"  "Done"                    "$X_HELP"  \
                         "S"  "Shell"                   "$S_HELP"  \
                         "P"  "Disable Guided Menu"     "$P_HELP"`

    elif  [  -z  "$DONE_CONFIG"  ];  then
#this menu presented after root has been selected and mounted
      ICOMMAND=`$DIALOG  --title "$TITLE"                          \
                         --nocancel                                \
                         --default-item  $ICOMMAND                 \
                         --item-help                               \
                         --menu                                    \
                         "$Y_HELP"                                 \
                         22 60 13                                  \
                         "D"  "Mount Filesystems and swap" "$D_HELP"  \
                         "G"  "Select Timezone"         "$G_HELP"  \
                         "H"  "Architecture Optimize"   "$H_HELP"  \
                         "K"  "Install/Configure Linux Kernel" "$K_HELP"  \
                         "L"  "Configure Log System"    "$L_HELP"  \
                         "M"  "Configure Bootloader"    "$M_HELP"  \
                         "N"  "Configure Networking"    "$N_HELP"  \
                         "O"  "Select optional spells to install" "$O_HELP" \
                         "X"  "Done"                    "$X_HELP"  \
                         "S"  "Shell"                   "$S_HELP"  \
                         "R"  "Restart Installation"    "$R_HELP"  \
                         "?"  "Installation Help"       "$IG_HELP" \
                         "P"  "Disable Guided Menu"     "$P_HELP"`

    else
# final stage
      ICOMMAND=`$DIALOG  --title "$TITLE"                              \
                         --nocancel                                    \
                         --default-item  $ICOMMAND                     \
                         --item-help                                   \
                         --menu                                        \
                         "$Q_HELP"                                     \
                         18 60 9                                       \
                         "I"  "Install Source Mage GNU/Linux to disk " "$I_HELP"   \
                         "J"  "Oops, I really need to compile a kernel " "$J_HELP" \
                         "M"  "Reconfigure ${BOOTLOADER}" "$M_HELP"                \
                         "U"  "Choose services to run at boot" "$U_HELP" \
                         "X"  "Done"                        "$X_HELP"  \
                         "S"  "Shell"                       "$S_HELP"  \
                         "R"  "Restart Installation"        "$R_HELP"  \
                         "?"  "Installation Help"           "$IG_HELP" \
                         "P"  "Disable Guided Menu"         "$P_HELP"`

    fi

  do

    case  $ICOMMAND in
      A)  introduction     ;;
      B)  nls              ;;
      C)  fdisc            ;;
      D)  mounty           ;;
      E)  mk_raid_device   ;;
      F)  mk_swap_file     ;;
      G)  timezone         ;;
      H)  optimize_architecture ;;
      J)  compile_kernel   ;;
      K)  make_kernel      ;;
      L)  syslog           ;;
      M)  config_bootloader ;;
      N)  network          ;;
      O)  spell_select     ;;
      I)  install_to_target ;;
      U)  service_select   ;;
      X)  goodbye          ;;
      S)  shell            ;;
      P)  toggle_guide     ;;
      T)  toggle_confirm   ;;
      R)  restart_install  ;;
      Z)  toggle_debug     ;;
      ?)  install_help     ;;
    esac

  done

}


main()  {

  export  PATH="/bin:/usr/bin:/sbin:/usr/sbin"

        ARCH=`uname -m`
        TARGET=${TARGET:=/mnt/root}
       CONFIRM=on
         GUIDE=on

    install_menu

}  


if [ -f /etc/installerdata/version ]
then . /etc/installerdata/version 
else VERSION=`date +%Y%m%d`-debug
fi

ARCH_SPECS=/var/lib/sorcery/archspecs

# The internal field separator is set to <tab> or <return>
IFS="	
"

DIALOG="dialog
--backtitle
Source Mage GNU/Linux Installer v. $VERSION 
--stdout"

trap  ":"  INT QUIT
main
