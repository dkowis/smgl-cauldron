#!/bin/bash
# This script processes the template replacement system in the ISO configuration
# data and copies the iso scripts and data into the chroot

# Pick up config
SCRIPTDIR=${0%/*}
. $SCRIPTDIR/config


if [ $# -lt 1 ] || [[ "$1" == "/" ]] ;then
  echo "usage: $0 <path_to_p4_in_chroot>"
  exit 1
fi


# Sanity check - maybe we should change this pathname sometime...
if [[ ${1: -8} != "/root/p4" ]] ;then
  echo "WARNING! The parameter of this script ($1) is supposed to be"
  echo "the directory where the scripts should be copied to. The recommended"
  echo "location is /root/p4 inside the chroot."
  echo "This directory will be rm -r'ed."
  echo ""
  read -t 10 -p "Do you still want to continue? [n]" -n 1 SANITY
  echo
  [[ "$SANITY" == "y" ]] || exit 2
fi


# We now get to the template processing functions.

# This processes a "multifile" template. That is, given a filename (e.g.
# data/config-2.6) and one or more suffixes (e.g. 'ppc'), it will choose
# the "most specific" file that exists (that is, data/config-2.6.ppc if it
# exists, otherwise data/config-2.6). This mechanism can be used if a
# file differs radically between architectures.
#
# If under a certain architecture a file/path should _not_ exist, add a
# symlink to "no/../op" as the file for that arch. An example for this
# mechanism is the skeleton/isolinux dir on the ppc architecture.
function choose_multi()
{
  local basicname foundname tempname

  if [[ -z $1 ]] ;then
    echo "choose_multi called on no file!"
    return 1
  fi # Things get really evil otherwise

  basicname="$1"
  tempname="$1"
  shift

  # We will now "build" the fully specialized filename,
  # and keep the most specific file we find
  while [ $# -gt 0 ] ;do
    # Add next suffix
    tempname="${tempname}.$1"
    # Does it exist? (dead symlink counts as "exists")
    [[ -L "$tempname" ]] || [[ -e "$tempname" ]] && foundname="$tempname"
    shift
  done

  # Did we find something?
  if [[ "$foundname" ]] ;then
    # Remove the base file/dir, if it exists
    rm -rf "$basicname"
    # Move us there
    mv "$foundname" "$basicname"
  fi

  # Remove all other specializations
  rm -rf "$basicname".*

  # Are we the special "blow this away" symlink?
  if [[ "$(readlink $basicname)" == "no/../op" ]] ;then
    rm -f "$basicname"
  fi
}


# This function will scan a given file for 'templates', that is, special
# strings that should be replaced (e.g. by the iso version), or lines that
# should be removed/added only in specific architectures.
# There once was a wiki page on this, but it got lost in our hd crash...
function process_templates()
{
  local pattern
  local line

  # Check if the file actually exists, if not, we get ugly errors here
  [[ -e "$1" ]] || return

  cp "$1"  ${TMP_DIR}/tmp.template

  # Apply each pattern replacement in data/smgl.patterns
  while read line ; do
    # We use eval so $VARIABLE expressions in the replacement work
    eval pattern="$line"

    sed -i "s/$pattern/g" ${TMP_DIR}/tmp.template

  done <${STATE_DIR}/smgl.patterns

  # Now, filter out the lines we don't want,
  # remove the template markers on those that we do
  cat ${TMP_DIR}/tmp.template |
  grep -v "^__SMGL_TEMPLATE_NOT_${ISO_ARCH}__" |
  grep -v "^__SMGL_TEMPLATE_NOT_${ISO_BRANCH}__" |
  sed 's/^__SMGL_TEMPLATE_NOT_[^_]*__//' |
  sed "s/^__SMGL_TEMPLATE_ONLY_${ISO_ARCH}__//" |
  sed "s/^__SMGL_TEMPLATE_ONLY_${ISO_BRANCH}__//" |
  grep -v "^__SMGL_TEMPLATE_ONLY_[^_]*__" >"$1"
  # we write the result to the file right ^^^^^ here

  rm ${TMP_DIR}/tmp.template
}



# ---- real script starts here ----

# Clean up target dir
rm -rf $1
mkdir -p $1

# Copy in our files
cp -a --no-preserve=ownership $SCRIPTDIR/../* $1

# redefine from config to point to the to-be-created dirs
STATE_DIR=$1/data
SKELETON=$1/skeleton
SCRIPTS=$1/generation-scripts

# Add changelog to skeleton
cp -a --no-preserve=ownership $SCRIPTDIR/../../ChangeLog $SKELETON

# Add smgl-isogen.conf, if we have one
[[ -e /etc/smgl-isogen.conf ]] && cp /etc/smgl-isogen.conf $1/../../etc/

# Create config for inside the chroot
{
  # Fix ISO_VERSION to a nonchanging value (you get fun when it's defined
  # dynamically via $(date) and it changes in the middle of generation)
  echo "ISO_VERSION=$ISO_VERSION"

  cat $SCRIPTDIR/config
} >$SCRIPTS/config


# As we would not have a chance to specify so otherwise,
# process the list of multi-files / templated files for templates.
choose_multi $STATE_DIR/smgl.multi $ISO_ARCH
choose_multi $STATE_DIR/smgl.templated $ISO_ARCH
choose_multi $STATE_DIR/smgl.patterns $ISO_ARCH
process_templates $STATE_DIR/smgl.multi
process_templates $STATE_DIR/smgl.templated
# Don't replace the patterns in the pattern replacement file though ;-)


# Process multi files
while read line ;do
  eval choose_multi $line
done <$STATE_DIR/smgl.multi


# Process templates
while read line ;do
  eval help="$line"
  process_templates "$help"
done <$STATE_DIR/smgl.templated


# Grab a new grimoire tarball if needed
if ! [ -e $1/../$GVERSION.tar.bz2 ] ;then
  echo "Missing grimoire tarball, fetching..."
  wget -O $1/../$GVERSION.tar.bz2 "http://codex.sourcemage.org/$GVERSION.tar.bz2"
fi

# Ditto for sorcery
if ! [ -e $1/../sorcery-$SVERSION.tar.bz2 ] ;then
  echo "Missing sorcery tarball, getting..."
  wget -O $1/../sorcery-$SVERSION.tar.bz2 "http://download.sourcemage.org/sorcery/sorcery-$SVERSION.tar.bz2"
fi
