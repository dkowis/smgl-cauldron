#!/bin/bash
# This file generates the actual .iso file.
# It's a bit lengthy, but manageable.


# Let's start with a little trick. The iso.packages file actually is a
# bash script, here we define the functions called from there.

#=====================================================================
## BEGIN of functions called from iso.packages
#=====================================================================

#---------------------------------------------------------------------
## @param file pattern to include by default
## Makes the given pattern be copied to the iso, overriding default_exclude
#---------------------------------------------------------------------
function add_default_include() {
  DEF_INCLUDE[${#DEF_INCLUDE[*]}]="$1"
}

#---------------------------------------------------------------------
## @param file pattern to exclude by default
## Makes the given pattern be not included on the iso, unless overridden
#---------------------------------------------------------------------
function add_default_exclude() {
  DEF_EXCLUDE[${#DEF_EXCLUDE[*]}]="$1"
}

#---------------------------------------------------------------------
## @params spell to unpack
## @Description
## This is the main unpacking function to use when installing stuff
## onto the ISO. Specify the spell name and the spell will be
## automatically unpacked to the ISO. Dependency tracking is not done.
#---------------------------------------------------------------------
function unpack() {
  begin_unpack "$1"
  end_unpack "$1"
}

#---------------------------------------------------------------------
## @param spell to unpack
## @Description
## This function prepares a spell to be installed
#---------------------------------------------------------------------
function begin_unpack() {
  local file

  # Clean up old unpack, if needed
  if [ -e $UNPACK_DIR ] ;then
    output_warning "An old unpack failed. Flushing the toilet."
    rm -rf $UNPACK_DIR
  fi
  mkdir $UNPACK_DIR

  # Extract tarball to a temporary location
  unpack_spell $1 ${UNPACK_DIR}         &&
  echo $1 >${TMP_DIR}/unpack_successful ||
  echo "unpacking \"$1\" failed."
}

#---------------------------------------------------------------------
## @param spell to install to ISO
## @Description
## Processes default includes and excludes, then copies what is left
## to the ISO root. Cleans up afterwards.
#---------------------------------------------------------------------
function end_unpack() {
  local entry

  # Copy files that should be copied in any case
  for entry in "${DEF_INCLUDE[@]}" ;do
    iso_include "$entry"
  done
  # Remove files that should not be copied
  for entry in "${DEF_EXCLUDE[@]}" ;do
    iso_exclude "$entry"
  done

  # Copy everything else, warn if there's nothing to copy
  if [ -e ${TMP_DIR}/unpack_successful ] ;then
    if ! cp -au ${UNPACK_DIR}/* ${ISO_DIR} 2>/dev/null ;then
      echo -n "nothing to be done for "
      cat ${TMP_DIR}/unpack_successful
    fi
    rm ${TMP_DIR}/unpack_successful

  # Hmm, the unpack went boom. bad.
  else
    fatal_warning "The unpack failed. Can't install to ISO"
  fi

  rm -rf ${UNPACK_DIR}
}

#---------------------------------------------------------------------
## @param shell pattern to include
## This function includes the given shell pattern to the ISO.
## This means that all files installed by the spell that match the
## given pattern will not be touched by later excludes.
#---------------------------------------------------------------------
function iso_include() {
  pushd ${UNPACK_DIR} >/dev/null
  eval "cp --parents -a ./$1 ${ISO_DIR}"
  popd >/dev/null
}

#---------------------------------------------------------------------
## @param path to include
## @param path to include as
## This function includes the given file/dir at the given location,
## effectively renaming it. Note that the file will still be
## installed to the original location too unless you exclude it.
#---------------------------------------------------------------------
function iso_include_as() {
  eval "mkdir -p $ISO_DIR/${2%/*}"
  eval "cp -a $UNPACK_DIR/$1 $ISO_DIR/$2"
}

#---------------------------------------------------------------------
## @param shell pattern to exclude
## This function excludes the given shell pattern to the ISO.
## This means that the files installed by the spell that match the
## given pattern will not get onto the ISO.
#---------------------------------------------------------------------
function iso_exclude() {
  eval "rm -rf ${UNPACK_DIR}/$1"
}

#=====================================================================
## END of functions called from iso.packages
#=====================================================================


# Okay, now some helper functions for installing and copying spells

#---------------------------------------------------------------------
## @param spell to unpack
## @param location to unpack to
## @Description
## Attempts to find and unpack the binary cache of the given spell
#---------------------------------------------------------------------
function unpack_spell() {
  if [ -e $CACHE_DIR/$1-$(get_ver_from_codex $1)-$ARCH.tar.bz2 ] ;then
    tar -xjf $CACHE_DIR/$1-$(get_ver_from_codex $1)-$ARCH.tar.bz2 -C $2
  else
    fatal_warning "Unable to unpack $1: No tarball found"
    return 1
  fi
}

#---------------------------------------------------------------------
## @param spell to unpack
## @param location to copy to
## @Description
## Attempts to copy the binary cache of the given spell to the given
## location.
#---------------------------------------------------------------------
function copy_spell_tarball() {
  if [ -e $CACHE_DIR/$1-$(get_ver_from_codex $1)-$ARCH.tar.bz2 ] ;then
    cp $CACHE_DIR/$1-$(get_ver_from_codex $1)-$ARCH.tar.bz2 $2
  else
    fatal_warning "Unable to copy tarball for $1: No tarball found"
    return 1
  fi
}

#---------------------------------------------------------------------
## @param spell name
## Gets the current grimoire version of the given spell
#---------------------------------------------------------------------
function get_ver_from_codex() {
  (
    . /etc/sorcery/config
    codex_set_current_spell_by_name $1
    echo $VERSION
  )
}


#---------------------------------------------------------------------
## @Description
## This function contains all the code for the dynamically-generated
## files the installer needs.
##
## It also copies the grimoire and sorcery packages and the linux sources
##
#---------------------------------------------------------------------
function create_statefiles() {

  # Copy codex and sorcery
  cp ${STATE_DIR}/../../$GVERSION.tar.bz2 ${ISO_DIR}/var/lib/sorcery/codex/
  cp ${STATE_DIR}/../../sorcery-$SVERSION.tar.bz2 ${ISO_DIR}/var/cache/sorcery/

  # Copy linux sources
  pushd /var/spool/sorcery >/dev/null
    cp $( summon -p source linux) ${ISO_DIR}/var/spool/sorcery
  popd >/dev/null


  # Generate spell descriptions and all the other goodies displayed in the
  # optional spell menu, also track spell conflicts
  echo "Pre-generating optional spell list..."
  ( # Subshell, so we don't mess up the caller's environment
    . /etc/sorcery/config

    # Get a list of all optional spells
    cat ${STATE_DIR}/optional-list | sed -e 's/#.*$//' -e 's/[[:blank:]]*$//' |
      grep -v '^$' >$TMP_DIR/optlist

    # Write out data for the optional spell menu (grabbed from sorcery)
    while read spell ; do
      codex_set_current_spell_by_name $spell >/dev/null
      echo "\"$spell\" \"$VERSION\" \"off\" \"$SHORT\""
    done <$TMP_DIR/optlist >${ISO_STATE_DIR}/optionalSpellList
    rm -f $TMP_DIR/optlist

    # Tricky hack: We redefine an internal sorcery function, hoping that the
    # CONFLICTS files are simple and just give us the conflicting spells
    # nicely on stdout this way
    function conflicts() { #redefinition
      echo "$SPELL:$1"
    }

    # Generate spell list and conflicts list
    while read spell ; do

      # get spell data
      codex_set_current_spell_by_name $spell >/dev/null

      # Generate packages list, with a pretend install date of "right now".
      echo "$SPELL:$(date +%Y%m%d):installed:$VERSION" \
        >>$ISO_DIR/var/state/sorcery/packages

      # Gather conflicts data, if possible
      [ -x $SPELL_DIRECTORY/CONFLICTS ] &&
        . $SPELL_DIRECTORY/CONFLICTS >>$ISO_DIR/var/lib/smgl.install/conflicts

    # The allspells file has been generated before we were called
    done <$TMP_DIR/allspells
  )

  # Add dependencies. Append, in case we want to "hardcode" some dependencies
  # in the skeleton tree
  cat $TMP_DIR/alldeps >>$ISO_DIR/var/state/sorcery/depends


  # Generate listings for the NLS menus
  echo "generating other pre-made lists..."
  pushd $ISO_DIR >/dev/null

  local file line

  find usr/share/keymaps -type f -not -path '*/include/*' |
    sed -e 's@^usr/share/keymaps/@@' -e 's@\.k\?map\.gz@@' |
    sort |
    while read line ;do
      echo "${line##*/}" #keymap name
      echo "${line%/*}"  #path leading up to it, e.g. "qwerty"
    done >>$ISO_STATE_DIR/keyMapList

  for file in usr/share/consolefonts/*.gz ;do
    echo "${file##*/}"
    gunzip -c "$file" | file - | sed 's/^.*, \?//' # font dimensions
  done >>$ISO_STATE_DIR/fontList

  for file in usr/share/i18n/locales/* ;do
    title=$(grep "^title" "$file" | cut -d '"' -f 2)
    if [ -n "$title" ] ;then
      echo "${file##*/}"
      echo "$title"
    fi
  done >>$ISO_STATE_DIR/languageList

  find usr/share/zoneinfo -mindepth 1 -type d -printf '/%h:%f:Directory\n' \
    >>$ISO_STATE_DIR/timeZoneList
  find usr/share/zoneinfo -type f |
  while read line ;do
    echo "/${line%/*}:${line##*/}:$(TZ="$ISO_DIR/$line" date +%z)"
  done >>$ISO_STATE_DIR/timeZoneList

  popd >/dev/null
}


#---------------------------------------------------------------------
## @Description
## This function runs through all spells that will have tarballs
## on the iso, and includes their dependencies.
##
## It also prunes the depends file down to what we actually need
##
## The list of spells is stored in $TMP_DIR/allspells, all depends
## go into $TMP_DIR/alldeps
#---------------------------------------------------------------------
function generate_sufficient_spells_list() {

  # Grab all spells
  cat ${STATE_DIR}/optional-list ${STATE_DIR}/install-list |
    filter_comments >$TMP_DIR/allspells

  NUM_LINES=0
  > $TMP_DIR/alldeps

  # This loop will keep adding "dependencies of all spells in the list"
  # to the list, so that we include multiple levels of dependencies.
  # It terminates when the number of spells in the list no longer increases
  # (as this means we didn't find any new dependencies)
  while [ "$NUM_LINES" != "$(wc -l $TMP_DIR/allspells)" ] ;do

    # Save new line count
    NUM_LINES=$(wc -l $TMP_DIR/allspells)

    # Grab dependencies
    local spell
    while read spell ;do
      grep "^$spell:[^:]*:on" /var/state/sorcery/depends
    done <$TMP_DIR/allspells >$TMP_DIR/moredeps

    # Parse depended-upon spells, remove the (FOO) construct for providers
    cat $TMP_DIR/moredeps | cut -d: -f2 | sed 's/(.*$//' >$TMP_DIR/morespells

    # Add new dependency data, remove duplicates
    mv $TMP_DIR/alldeps $TMP_DIR/olddeps
    cat $TMP_DIR/olddeps $TMP_DIR/moredeps | sort -u >$TMP_DIR/alldeps
    rm -f $TMP_DIR/olddeps $TMP_DIR/moredeps

    # Add new spells to the list, remove duplicates
    mv $TMP_DIR/allspells $TMP_DIR/oldspells
    cat $TMP_DIR/oldspells $TMP_DIR/morespells | sort -u >$TMP_DIR/allspells
    rm -f $TMP_DIR/oldspells $TMP_DIR/morespells

  done # repeat until number of lines does not change anymore

  # Result files are already where they belong.
}


#---------------------------------------------------------------------
## @stdin stream of text with comments
## @stdout same stream with comments, trailing whitespace and empty lines stripped.
## Note that you cannot escape a hash mark.
#---------------------------------------------------------------------
function filter_comments() {
  sed -e 's/#.*$//' -e 's/[[:blank:]]*$//' | grep -v '^$'
}



# ---- actual script starts here ----

. ${0%/*}/config

# cleanup/setup
rm -rf ${ISO_DIR}
mkdir -p $ISO_DIR
TMP_DIR="/tmp/mkiso.$$"
UNPACK_DIR="${TMP_DIR}/unpack"
rm -rf $TMP_DIR
mkdir -m700 $TMP_DIR
declare -a DEF_INCLUDE
declare -a DEF_EXCLUDE

echo "Creating ISO file structure..."

# Create dirs
while read line ; do
  mkdir -p ${ISO_DIR}/${line}
done <${STATE_DIR}/iso.dirs

# Install (unpack) packages needed
. ${STATE_DIR}/iso.packages

# Create static /dev, and the pipe init needs
# (it normally creates it on bootup, but that's hard on a read-only iso9660 fs)
pushd $ISO_DIR/dev >/dev/null
 $SKELETON/sbin/MAKEDEV generic-nopty md
 mknod initctl p
popd >/dev/null

cp ${STATE_DIR}/initrd.gz $ISO_DIR/boot/initrd.gz

echo "Copying cache tarballs..."

generate_sufficient_spells_list

# Copy tarballs the installer will be able to install
while read spell ; do
  copy_spell_tarball $spell ${ISO_DIR}/var/cache/sorcery/
done <${TMP_DIR}/allspells


# Finally, add the skeleton files on top (except for the initrd)
# TODO: is a find construct with -prune cleaner?
pushd $SKELETON >/dev/null
cp -af --parents $(find * -maxdepth 0 ! -name initrd) $ISO_DIR
popd >/dev/null

# Same dusty old hook as in mkiso, allow for a "patch file" for last-minute mods
[ -e ${STATE_DIR}/iso.patch ] &&
  patch -d $ISO_DIR -p0 ${STATE_DIR}/iso.patch

# Create library caches and symlinks
cp /sbin/ldconfig ${ISO_DIR}
chroot ${ISO_DIR} /ldconfig
rm ${ISO_DIR}/ldconfig

# Create module tables (and be compatible to 2.4 kernels, fwiw)
cp /sbin/depmod /sbin/depmod.old ${ISO_DIR}
chroot ${ISO_DIR} /depmod $KERNEL_VERSION
rm ${ISO_DIR}/depmod ${ISO_DIR}/depmod.old


# Install sorcery
mkdir ${ISO_DIR}/tmpsorcery
tar -C ${ISO_DIR}/tmpsorcery -xjf ${STATE_DIR}/../../sorcery-$SVERSION.tar.bz2
chroot ${ISO_DIR} sh -c "cd /tmpsorcery/sorcery ; ./install"
rm -r ${ISO_DIR}/tmpsorcery


echo "Generating installer-related files"
create_statefiles


# Command hook (this is actually used here)
# This does some fixes, and puts the initrd size and grimoire version
# into the bootloader config files
[ -e ${STATE_DIR}/iso.command ] &&
  . ${STATE_DIR}/iso.command

rm -r ${TMP_DIR}

# all systems ready
echo "generating ISO, outputting to /$ISO_FILENAME"


# ISO ends up in the / directory of the chroot
# This last script calls mkisofs with the correct arguments for our arch.
. ${STATE_DIR}/iso.mkfscommand /$ISO_FILENAME $ISO_DIR
